import React, { useState, useCallback, useEffect } from "react";
import "./diceShootout.scss";
import GameContainer from "../../components/GameContainer/GameContainer";
import { IMAGES } from "../../constant/images";
import { PATHS } from "../../path/paths";
import { useNavigate } from "react-router-dom";
import { GiHamburgerMenu } from "react-icons/gi";
import {
  FaGamepad,
  FaCog,
  FaHome,
  FaFileAlt,
  FaScroll,
  FaBars,
  FaVolumeMute,
  FaMusic,
  FaQuestionCircle,
} from "react-icons/fa";
import { IoClose } from "react-icons/io5";
import ActionButton from "../../components/Button/ActionButton/ActionButton";
import useGameSounds from "../../hooks/useGameSounds";

// Rive dice
import {
  useRive,
  useStateMachineInput,
  Layout,
  Fit,
  Alignment,
} from "@rive-app/react-canvas";
import Victory from "../../components/GameOver/Victory";
import Defeat from "../../components/GameOver/Defeat";
import InfoButton from "../../components/Button/InfoButtons/InfoButton";
import Modal from "../../components/Modal/Modal";
import SettingsModal from "../../components/Modal/SettingsModal";
import ControlsModal from "../../components/Modal/ControlsModal";
import useSpriteController from "../../hooks/useSpriteController";

type Props = { mode?: "B1" | "B2"; skipSelect?: boolean };

const MAX_HP = 50;
const HEAL_AMOUNT = 10;
const MAX_HEALS = 3;
// Timing constants
const ROLL_ANIM_MS = 1000;
const RESULT_HOLD_MS = 500;
const BOT_ACT_DELAY_MS = 1000;
const CLASH_MS = 1500; // 500ms in + 1500ms hold + 500ms out

// Optional: enable Degen Mode (6 crit = 12 dmg, +20 bonus if healed at <=5 and won).
const DEGEN_ENABLED = false;

const IDLE_FPS = 6;
const PUNCH_FPS = 48,
  PUNCHED_FPS = 6,
  WIN_LOSE_FPS = 6,
  POWER_PUNCH_FPS = 15;

function clamp(n: number, min: number, max: number) {
  return Math.max(min, Math.min(max, n));
}
function rand1to6() {
  return 1 + Math.floor(Math.random() * 6);
}

function rollTwoDice() {
  return [rand1to6(), rand1to6()] as const;
}

function RiveDice({
  rolling,
  onEnd,
  showNumber,
  outcome,
  src = "/dice.riv",
  size = 240,
}: {
  rolling: boolean;
  onEnd?: () => void;
  showNumber: number | null;
  outcome: number | null;
  src?: string;
  size?: number;
}) {
  const { rive, RiveComponent } = useRive({
    src,
    autoplay: false,
    stateMachines: "State Machine 1",
    layout: new Layout({ fit: Fit.Contain, alignment: Alignment.Center }),
  });
  const rollTrigger = useStateMachineInput(
    rive,
    "State Machine 1",
    "roll",
    Number(outcome)
  );

  // Keep the die displaying the last outcome when not rolling
  React.useEffect(() => {
    if (!rive) return;
    try {
      // Set numeric value if available (to hold final face)
      // @ts-ignore
      if (rollTrigger && typeof (rollTrigger as any).value !== "undefined") {
        // @ts-ignore
        (rollTrigger as any).value = Number(outcome ?? 1);
      }
      // Keep machine paused when not rolling so face persists
      if (!rolling) {
        try {
          rive.pause();
        } catch {}
      }
    } catch {}
  }, [rive, rollTrigger, outcome, rolling]);

  React.useEffect(() => {
    if (!rive || !rolling) return;
    try {
      // Ensure outcome is set before triggering animation
      // @ts-ignore
      if (rollTrigger && typeof (rollTrigger as any).value !== "undefined") {
        // @ts-ignore
        (rollTrigger as any).value = Number(outcome ?? 1);
      }
      // Fire trigger if available or play the machine
      // @ts-ignore
      if (rollTrigger && typeof (rollTrigger as any).fire === "function") {
        // @ts-ignore
        (rollTrigger as any).fire();
      } else {
        rive.play();
      }
    } catch {}

    const t = setTimeout(() => {
      try {
        rive.pause();
      } catch {}
      onEnd?.();
    }, ROLL_ANIM_MS);
    return () => clearTimeout(t);
  }, [rolling, rive, rollTrigger, outcome, onEnd]);

  return (
    <div style={{ position: "relative", width: size, height: size }}>
      <div
        style={{
          position: "absolute",
          inset: 0,
          borderRadius: 16,
          // overflow: "hidden",
          // boxShadow: "0 6px 24px rgba(0,0,0,0.35)",
          // background: "rgba(0,0,0,0.2)",
        }}
      >
        <RiveComponent />
      </div>
      {showNumber != null && (
        <div
          style={{
            position: "absolute",
            inset: 0,
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
            fontSize: 96,
            fontWeight: 900,
            color: "white",
            textShadow: "0 2px 10px rgba(0,0,0,0.6)",
            pointerEvents: "none",
          }}
        >
          {showNumber}
        </div>
      )}
    </div>
  );
}

const DiceShootout = (props: Props) => {
  const isBattleTwo = props.mode === "B2";
  const navigate = useNavigate();
  // Core state
  const [playerHP, setPlayerHP] = React.useState<number>(MAX_HP);
  const [botHP, setBotHP] = React.useState<number>(MAX_HP);
  const [playerHeals, setPlayerHeals] = React.useState<number>(
    isBattleTwo ? 0 : MAX_HEALS
  );
  const [botHeals, setBotHeals] = React.useState<number>(MAX_HEALS);
  const [turn, setTurn] = React.useState<"player" | "bot" | "over">("player");
  const [rolling, setRolling] = React.useState<boolean>(false);
  const [lastRoll, setLastRoll] = React.useState<number | null>(null);
  const [lastRoll2, setLastRoll2] = React.useState<number | null>(null);
  const [lastAction, setLastAction] = React.useState<"attack" | "heal" | null>(
    null
  );
  const [lastPlayerAction, setLastPlayerAction] = React.useState<
    "attack" | "heal" | null
  >(null);

  const [showDice, setShowDice] = React.useState<boolean>(true);
  const [revealing, setRevealing] = React.useState<boolean>(false);
  const [clashSide, setClashSide] = useState<"player" | "bot" | null>(null);
  const [retroNumbers, setRetroNumbers] = useState<
    Array<{
      id: number;
      value: string;
      type: "damage" | "heal";
      target: "player" | "bot";
      x: number;
      y: number;
    }>
  >([]);
  const [playerHitTilt, setPlayerHitTilt] = useState(false);
  const [botHitTilt, setBotHitTilt] = useState(false);
  const [gameLog, setGameLog] = useState<
    Array<{ id: number; message: string; timestamp: number }>
  >([]);
  const [retroMessage, setRetroMessage] = useState<{
    id: number;
    text: string;
    type: "double" | "max" | "critical";
  } | null>(null);
  const [opponentDialogue, setOpponentDialogue] = useState<{
    id: number;
    text: string;
  } | null>(null);
  const [lastActionTime, setLastActionTime] = useState<number>(Date.now());
  const [rollScore, setRollScore] = useState<number | null>(null);
  const [fightBanner, setFightBanner] = useState<boolean>(false);
  const [koBanner, setKoBanner] = useState<boolean>(false);
  const [bannerText, setBannerText] = useState<string | null>(null);
  const [bannerClass, setBannerClass] = useState<string>("");
  const flashBanner = React.useCallback((text: string, cls: string = "") => {
    setBannerText(text);
    setBannerClass(cls);
    setTimeout(() => setBannerText(null), 1200);
  }, []);
  const [postVersusVisible, setPostVersusVisible] = useState<boolean>(false);
  const [winnerSide, setWinnerSide] = useState<"player" | "bot" | null>(null);
  const [currentTargetFace, setCurrentTargetFace] = useState<number | null>(
    null
  );
  // Round completion tracking (both sides acted)
  const playerTurnDoneRef = React.useRef<boolean>(false);
  const botTurnDoneRef = React.useRef<boolean>(false);
  const handleTurnComplete = React.useCallback((actor: "player" | "bot") => {
    if (actor === "player") playerTurnDoneRef.current = true;
    else botTurnDoneRef.current = true;
    if (playerTurnDoneRef.current && botTurnDoneRef.current) {
      setPlayerSpecialMeter((m) => clamp(m + 1, 0, 5));
      setBotSpecialMeter((m) => clamp(m + 1, 0, 5));
      playerTurnDoneRef.current = false;
      botTurnDoneRef.current = false;
    }
  }, []);

  // Optional scoring with Degen clutch bonus
  const [playerPts, setPlayerPts] = React.useState<number>(0);
  const [botPts, setBotPts] = React.useState<number>(0);
  const [playerClutchHeal, setPlayerClutchHeal] =
    React.useState<boolean>(false);
  const [botClutchHeal, setBotClutchHeal] = React.useState<boolean>(false);

  // Small UI badges (+/-) near avatars

  const [sidebarOpen, setSidebarOpen] = useState(false);
  const [settingsOpen, setSettingsOpen] = useState(false);
  const [controlsOpen, setControlsOpen] = useState(false);
  const [helpOpen, setHelpOpen] = useState(false);
  const [showVersus, setShowVersus] = useState<boolean>(true);
  const [versusCountdown, setVersusCountdown] = useState<number>(5);
  const [playerSpecialMeter, setPlayerSpecialMeter] = useState<number>(0); // 0..5
  const [botSpecialMeter, setBotSpecialMeter] = useState<number>(0); // 0..5
  const [showOpponentSelect, setShowOpponentSelect] = useState<boolean>(
    props.skipSelect ? false : true
  );
  const [selectedOpponent, setSelectedOpponent] = useState<1 | 2 | 3 | null>(
    isBattleTwo ? 2 : null
  );

  // FX state
  const [shake, setShake] = React.useState<boolean>(false);
  const [jolt, setJolt] = React.useState<boolean>(false);
  const [playerHitFx, setPlayerHitFx] = React.useState<boolean>(false);
  const [botHitFx, setBotHitFx] = React.useState<boolean>(false);
  const [playerHealFx, setPlayerHealFx] = React.useState<boolean>(false);
  const [botHealFx, setBotHealFx] = React.useState<boolean>(false);
  const [playerTargetGlow, setPlayerTargetGlow] =
    React.useState<boolean>(false);
  const [botTargetGlow, setBotTargetGlow] = React.useState<boolean>(false);
  const [impactSparks, setImpactSparks] = React.useState<
    Array<{ id: number; left: string; top: string }>
  >([]);
  const [playerLowWarned, setPlayerLowWarned] = React.useState<boolean>(false);
  const [botLowWarned, setBotLowWarned] = React.useState<boolean>(false);

  const playerSprite = useSpriteController("A");
  const botSprite = useSpriteController("B");

  // Impact FX helper: flash, sparks, brief screen shake
  const triggerImpactFx = useCallback(() => {
    // Brief camera shake
    setShake(true);
    setTimeout(() => setShake(false), 380);

    // Quick jolt
    setJolt(true);
    setTimeout(() => setJolt(false), 240);

    // Sparks around clash center (50%, 55%) with random offsets
    const sparks = Array.from({ length: 6 }).map((_, i) => {
      const dx = Math.round((Math.random() - 0.5) * 120); // -60..60
      const dy = Math.round((Math.random() - 0.5) * 80); // -40..40
      return {
        id: Date.now() + i,
        left: `calc(50% + ${dx}px)`,
        top: `calc(55% + ${dy}px)`,
      };
    });
    setImpactSparks(sparks);
    setTimeout(() => setImpactSparks([]), 520);
  }, []);

  // Sounds
  const {
    playDiceRoll,
    playDamageDone,
    playDamageTaken,
    playHealDone,
    playHealTaken,
    playSidebarOpen,
    playVictory,
    playDefeat,
    playLowHP,
    playGameOver,
    playFight,
    playAudienceCheer,
    playAudienceBoo,
    playBackgroundMusic,
    stopBackgroundMusic,
    toggleMusicMute,
    isMusicMuted,
    isMusicPlaying,
  } = useGameSounds();

  // Helpers to display bars
  const playerHPWidth = `${(playerHP / MAX_HP) * 100}%`;
  const botHPWidth = `${(botHP / MAX_HP) * 100}%`;

  const endGame = React.useCallback(
    (winner: "player" | "bot") => {
      setTurn("over");
      setKoBanner(true);
      setTimeout(() => setKoBanner(false), 1200);
      if (winner === "player") {
        let add = 25;
        if (DEGEN_ENABLED && playerClutchHeal) add += 20;
        setPlayerPts((p) => p + add);
      } else {
        let add = 25;
        if (DEGEN_ENABLED && botClutchHeal) add += 20;
        setBotPts((p) => p + add);
      }
      // Heavy shake + KO + game over sting
      setShake(true);
      setTimeout(() => setShake(false), 700);
      playDefeat();
      setTimeout(() => playGameOver(), 350);
      // Show post-battle versus overlay with winner highlight
      setTimeout(() => {
        setWinnerSide(winner);
        setPostVersusVisible(true);
      }, 800);
    },
    [playerClutchHeal, botClutchHeal]
  );

  const addLogEntry = React.useCallback((message: string) => {
    const newEntry = {
      id: Date.now(),
      message,
      timestamp: Date.now(),
    };
    setGameLog((prev) => {
      const updated = [newEntry, ...prev.slice(0, 1)]; // Keep only 2 entries
      return updated;
    });
  }, []);

  const showRetroMessage = React.useCallback(
    (text: string, type: "double" | "max" | "critical") => {
      const id = Date.now();
      setRetroMessage({ id, text, type });

      // Remove message after animation
      setTimeout(() => {
        setRetroMessage(null);
      }, 2000);
    },
    []
  );

  const showOpponentDialogue = useCallback((text: string) => {
    const id = Date.now();
    setOpponentDialogue({ id, text });

    // Remove dialogue after 3 seconds
    setTimeout(() => {
      setOpponentDialogue(null);
    }, 3000);
  }, []);

  const showDoubleRollDialogue = useCallback(
    (isDouble: boolean) => {
      if (isDouble) {
        const message =
          Math.random() > 0.5 ? "Double Trouble!" : "Lucky Bastard";
        showOpponentDialogue(message);
      }
    },
    [showOpponentDialogue]
  );

  // Idle detection and dialogue
  React.useEffect(() => {
    const checkIdle = () => {
      const now = Date.now();
      const idleTime = now - lastActionTime;

      if (idleTime > 15000) {
        // 15 seconds - audience boo
        playAudienceBoo();
        setLastActionTime(now); // Reset timer
      } else if (idleTime > 10000) {
        // 10 seconds - opponent taunt
        const taunts = ["*****", "Come at me kid!", "Noob boy", "You Afraid?"];
        const randomTaunt = taunts[Math.floor(Math.random() * taunts.length)];
        showOpponentDialogue(randomTaunt);
        setLastActionTime(now); // Reset timer
      }
    };

    const interval = setInterval(checkIdle, 1000); // Check every second
    return () => clearInterval(interval);
  }, [lastActionTime, showOpponentDialogue, playAudienceBoo]);

  // Attack and Heal
  const doAttack = React.useCallback(
    async (who: "player" | "bot") => {
      if (rolling || turn !== who || revealing) return;

      // Update last action time
      setLastActionTime(Date.now());

      const [r1, r2] = rollTwoDice();
      const base = r1 + r2;
      const isDouble = r1 === r2;
      const isDouble1 = isDouble && r1 === 1;
      const isCritical = base === 12;
      const damage = isCritical ? 20 : isDouble ? base * 2 : base;

      // Add log entry
      const attacker = who === "player" ? "You" : "Opponent";
      // Start dice: show + rolling phase
      setShowDice(true);
      setRevealing(true); // mark sequence busy to prevent duplicate bot actions
      setRolling(true);
      setLastRoll(r1);
      setLastRoll2(r2);
      setLastAction("attack");
      if (who === "player") setLastPlayerAction("attack");

      playDiceRoll();
      // Critical haptic feedback for roll of 12
      if (isCritical && "vibrate" in navigator) {
        navigator.vibrate([100, 50, 100, 50, 200]);
      }

      // Show retro message for doubles
      if (isDouble) {
        if (isDouble1) {
          showRetroMessage("DOUBLE 1!", "double");
        } else {
          showRetroMessage("DOUBLE!", "double");
        }
      } else if (isCritical) {
        showRetroMessage("MAX DAMAGE!", "max");
        flashBanner("Maximum Damage");
      }

      // Show hit marker 500ms before roll animation ends
      const earlyMs = Math.max(0, ROLL_ANIM_MS - 500);
      setTimeout(() => {
        if (who === "player") {
          setBotHitFx(true);
          setTimeout(() => setBotHitFx(false), 600);
        } else {
          setPlayerHitFx(true);
          setTimeout(() => setPlayerHitFx(false), 600);
        }
      }, earlyMs);

      // After dice animation, start clash, then apply damage on return
      setTimeout(() => {
        setRolling(false);
        // Battle 2: penalty on any 1 rolled => self-damage and skip clash
        if (isBattleTwo && (r1 === 1 || r2 === 1)) {
          const selfPenalty = r1 === 1 && r2 === 1 ? 10 : 5;
          const msg =
            r1 === 1 && r2 === 1 ? "Double 1’s, -10 HP!" : "1 rolled! -5 HP";
          flashBanner(msg, "banner-danger");
          addLogEntry(
            `${
              who === "player" ? "You" : "Opponent"
            } suffered ${selfPenalty} damage (rolled 1).`
          );
          let ko = false;
          if (who === "player") {
            setPlayerHP((hp) => {
              const newHP = clamp(hp - selfPenalty, 0, MAX_HP);
              if (newHP <= 0) ko = true;
              return newHP;
            });
          } else {
            setBotHP((hp) => {
              const newHP = clamp(hp - selfPenalty, 0, MAX_HP);
              if (newHP <= 0) ko = true;
              return newHP;
            });
          }
          if (ko) {
            endGame(who === "player" ? "bot" : "player");
            return;
          }
          setTimeout(() => {
            setShowDice(true);
            setTurn((t) =>
              t === "over" ? "over" : who === "player" ? "bot" : "player"
            );
            setRevealing(false);
            handleTurnComplete(who);
          }, RESULT_HOLD_MS);
          return;
        }
        setShowDice(false); // dice disappear during clash
        setClashSide(who);
        setRollScore(base); // show total rolled amount
        // play hit during the clash
        playFight();
        triggerImpactFx();

        // Start sprite anims for the clash
        if (who === "player") {
          playerSprite
            .play("punch", { fps: PUNCH_FPS, loop: true })
            .catch(() => {});

          botSprite
            .play("punched", { fps: PUNCHED_FPS, loop: false })
            .catch(() => {});
        } else {
          botSprite
            .play("punch", { fps: PUNCH_FPS, loop: true })
            .catch(() => {});
          playerSprite
            .play("punched", { fps: PUNCHED_FPS, loop: false })
            .catch(() => {});
        }

        setTimeout(() => {
          // after clash animation
          setClashSide(null); // end clash animation

          playerSprite.setIdle();
          botSprite.setIdle();

          // Play audience reaction for special rolls
          if (isDouble1) {
            playAudienceBoo();
          } else if (isDouble || isCritical) {
            playAudienceCheer();
          }

          // Add log entry once for the attack
          addLogEntry(`${attacker} attacked and dealt ${damage} damage.`);
          // Battle 2 target success increments player heals and refresh target
          if (
            isBattleTwo &&
            currentTargetFace &&
            (r1 === currentTargetFace || r2 === currentTargetFace)
          ) {
            if (who === "player") {
              setPlayerHeals((h) => Math.min(MAX_HEALS, h + 1));
              setPlayerTargetGlow(true);
              setTimeout(() => setPlayerTargetGlow(false), 1000);
            } else {
              setBotTargetGlow(true);
              setTimeout(() => setBotTargetGlow(false), 1000);
            }
            // new shared target for next turns
            const next = 2 + Math.floor(Math.random() * 5);
            setCurrentTargetFace(next);
          }

          // Show opponent dialogue based on damage dealt
          if (who === "player") {
            if (damage >= 10) {
              showOpponentDialogue("You got hands!");
            } else if (damage <= 2) {
              showOpponentDialogue("Ant punch");
            }
            // Show double roll dialogue for player
            showDoubleRollDialogue(isDouble);
          } else {
            if (damage > 9) {
              showOpponentDialogue("Too easy!");
            }
            // Show double roll dialogue for bot
            showDoubleRollDialogue(isDouble);
          }

          if (who === "player") {
            setBotHP((hp) => {
              const prevHP = hp;
              const newHP = clamp(hp - damage, 0, MAX_HP);
              addRetroNumber(damage, "damage", "bot");
              triggerAvatarHitTilt("bot");
              // Damage SFX
              playDamageTaken();
              playDamageDone();
              if (newHP <= 10 && !botLowWarned && newHP > 0) {
                playLowHP();
                setBotLowWarned(true);
              }
              // Bot HP fell below 10 threshold => bot gains +1 meter (comeback)
              if (newHP <= 10 && prevHP > 10) {
                setBotSpecialMeter((m) => clamp(m + 1, 0, 5));
                flashBanner("Do or Die", "banner-danger");
              }
              if (newHP <= 0) endGame("player");
              return newHP;
            });

            // Special meter: +1 per 10 damage, +1 if double
            if (damage >= 10) setPlayerSpecialMeter((m) => clamp(m + 1, 0, 5));
            if (isDouble) setPlayerSpecialMeter((m) => clamp(m + 1, 0, 5));
          } else {
            setPlayerHP((hp) => {
              const prevHP = hp;
              const newHP = clamp(hp - damage, 0, MAX_HP);
              addRetroNumber(damage, "damage", "player");
              triggerAvatarHitTilt("player");
              // Damage SFX
              playDamageTaken();
              playDamageDone();
              if (newHP <= 10 && !playerLowWarned && newHP > 0) {
                playLowHP();
                setPlayerLowWarned(true);
              }
              // Player HP fell below 10 threshold => player gains +1 meter (comeback)
              if (newHP <= 10 && prevHP > 10) {
                setPlayerSpecialMeter((m) => clamp(m + 1, 0, 5));
                flashBanner("Do or Die", "banner-danger");
              }
              if (newHP <= 0) endGame("bot");
              return newHP;
            });

            // Bot special meter increments for bot attack
            if (damage >= 10) setBotSpecialMeter((m) => clamp(m + 1, 0, 5));
            if (isDouble) setBotSpecialMeter((m) => clamp(m + 1, 0, 5));
          }

          // Wait, then proceed to next turn and show dice again (unless game over)
          setTimeout(() => {
            // playerSprite.setIdle();
            // botSprite.setIdle();
            setRollScore(null); // hide scoreboard before next turn
            setShowDice(true); // Show dice again
            setTurn((t) =>
              t === "over" ? "over" : who === "player" ? "bot" : "player"
            );
            setRevealing(false); // sequence complete
            handleTurnComplete(who);
          }, RESULT_HOLD_MS);
        }, CLASH_MS); // Wait for clash animation to complete
      }, ROLL_ANIM_MS);
    },
    [
      rolling,
      turn,
      endGame,
      revealing,
      playDiceRoll,
      playDamageDone,
      playDamageTaken,
      playLowHP,
      botLowWarned,
      playerLowWarned,
      showRetroMessage,
      playAudienceCheer,
      playAudienceBoo,
      showOpponentDialogue,
      showDoubleRollDialogue,
      handleTurnComplete,
      isBattleTwo,
      currentTargetFace,
    ]
  );

  const doHeal = React.useCallback(
    async (who: "player" | "bot") => {
      if (rolling || turn !== who || revealing) return;

      // Update last action time
      setLastActionTime(Date.now());

      const [r1, r2] = rollTwoDice();
      const base = r1 + r2;
      const isDouble = r1 === r2;
      const isDouble1 = isDouble && r1 === 1;
      const isCritical = base === 12;
      const healValue = isDouble ? base * 2 : base;

      // Add log entry
      const healer = who === "player" ? "You" : "Opponent";
      // Start dice: show + rolling phase
      setShowDice(true);
      setRevealing(true); // block duplicate actions during sequence
      setRolling(true);
      setLastRoll(r1);
      setLastRoll2(r2);
      setLastAction("heal");
      if (who === "player") setLastPlayerAction("heal");

      playDiceRoll();
      // Critical haptic feedback for roll of 12
      if (isCritical && "vibrate" in navigator) {
        navigator.vibrate([100, 50, 100, 50, 200]);
      }

      // Show retro message for doubles
      if (isDouble) {
        if (isDouble1) {
          showRetroMessage("DOUBLE 1!", "double");
        } else {
          showRetroMessage("DOUBLE!", "double");
        }
      } else if (isCritical) {
        showRetroMessage("MAX HEAL!", "max");
        flashBanner("Maximum Damage");
      }

      setTimeout(() => {
        setRolling(false);
        // Battle 2: penalty on any 1 rolled => self-damage and skip heal
        if (isBattleTwo && (r1 === 1 || r2 === 1)) {
          const selfPenalty = r1 === 1 && r2 === 1 ? 10 : 5;
          const msg =
            r1 === 1 && r2 === 1
              ? "Double 1’s, bad news!"
              : "Unlucky! 1 rolled";
          flashBanner(msg, "banner-danger");
          addLogEntry(
            `${
              who === "player" ? "You" : "Opponent"
            } suffered ${selfPenalty} damage (rolled 1).`
          );
          let ko = false;
          if (who === "player") {
            setPlayerHP((hp) => {
              const newHP = clamp(hp - selfPenalty, 0, MAX_HP);
              if (newHP <= 0) ko = true;
              return newHP;
            });
          } else {
            setBotHP((hp) => {
              const newHP = clamp(hp - selfPenalty, 0, MAX_HP);
              if (newHP <= 0) ko = true;
              return newHP;
            });
          }
          if (ko) {
            endGame(who === "player" ? "bot" : "player");
            return;
          }
          // Target success check
          if (
            who === "player" &&
            currentTargetFace &&
            (r1 === currentTargetFace || r2 === currentTargetFace)
          ) {
            if (who === "player") {
              setPlayerHeals((h) => Math.min(MAX_HEALS, h + 1));
              setPlayerTargetGlow(true);
              setTimeout(() => setPlayerTargetGlow(false), 1000);
            } else {
              setBotTargetGlow(true);
              setTimeout(() => setBotTargetGlow(false), 1000);
            }
            const next = 2 + Math.floor(Math.random() * 5);
            setCurrentTargetFace(next);
          }
          setTimeout(() => {
            setShowDice(true);
            setTurn((t) =>
              t === "over" ? "over" : who === "player" ? "bot" : "player"
            );
            setRevealing(false);
            handleTurnComplete(who);
          }, RESULT_HOLD_MS);
          return;
        }
        setShowDice(false);

        // Play audience reaction for special rolls
        if (isDouble1) {
          playAudienceBoo();
        } else if (isDouble || isCritical) {
          playAudienceCheer();
        }

        // Add log entry once for the heal
        addLogEntry(`${healer} healed for ${healValue} HP.`);
        // Battle 2 target match increases player heals and refresh target
        if (
          isBattleTwo &&
          currentTargetFace &&
          (r1 === currentTargetFace || r2 === currentTargetFace)
        ) {
          if (who === "player") {
            setPlayerHeals((h) => Math.min(MAX_HEALS, h + 1));
            setPlayerTargetGlow(true);
            setTimeout(() => setPlayerTargetGlow(false), 1000);
          } else {
            setBotTargetGlow(true);
            setTimeout(() => setBotTargetGlow(false), 1000);
          }
          const next = 2 + Math.floor(Math.random() * 5);
          setCurrentTargetFace(next);
        }

        // Show opponent dialogue for low heal amounts
        if (who === "player" && healValue < 5) {
          showOpponentDialogue("That much ain't gonna save you");
        }
        // Show double roll dialogue for healing
        showDoubleRollDialogue(isDouble);

        // Special meter: +1 if roller rolled doubles on heal
        if (isDouble) {
          if (who === "player")
            setPlayerSpecialMeter((m) => clamp(m + 1, 0, 5));
          else setBotSpecialMeter((m) => clamp(m + 1, 0, 5));
        }

        if (who === "player") {
          setPlayerHeals((h) => Math.max(0, h - 1));
          setPlayerHP((hp) => {
            if (hp <= 5 && DEGEN_ENABLED) setPlayerClutchHeal(true);
            const healed = Math.min(MAX_HP, hp + healValue);
            const actualHealValue = healed - hp;
            // Add retro heal number
            addRetroNumber(actualHealValue, "heal", "player");
            triggerAvatarHitTilt("player");
            playHealDone();
            setPlayerHealFx(true);
            setTimeout(() => setPlayerHealFx(false), 600);
            return healed;
          });
        } else {
          setBotHeals((h) => Math.max(0, h - 1));
          setBotHP((hp) => {
            if (hp <= 5 && DEGEN_ENABLED) setBotClutchHeal(true);
            const healed = Math.min(MAX_HP, hp + healValue);
            const actualHealValue = healed - hp;
            // Add retro heal number
            addRetroNumber(actualHealValue, "heal", "bot");
            triggerAvatarHitTilt("bot");
            playHealDone();
            setBotHealFx(true);
            setTimeout(() => setBotHealFx(false), 600);
            return healed;
          });
        }

        // Wait, then proceed to next turn and show dice again (unless game over)
        setTimeout(() => {
          setRollScore(null); // hide scoreboard before next turn
          setShowDice(true);
          setTurn((t) =>
            t === "over" ? "over" : who === "player" ? "bot" : "player"
          );
          setRevealing(false);
          handleTurnComplete(who);
        }, RESULT_HOLD_MS);
      }, ROLL_ANIM_MS);
    },
    [
      rolling,
      revealing,
      turn,
      playerHeals,
      botHeals,
      playerHP,
      botHP,
      playDiceRoll,
      playHealDone,
      showRetroMessage,
      playAudienceCheer,
      playAudienceBoo,
      showOpponentDialogue,
      showDoubleRollDialogue,
      handleTurnComplete,
      isBattleTwo,
      currentTargetFace,
    ]
  );

  // Player Special move
  // const doSpecial = React.useCallback(async () => {
  //   if (rolling || revealing || turn !== "player") return;
  //   if (playerSpecialMeter < 5) return;

  //   // Begin special sequence similar to clash
  //   setLastActionTime(Date.now());
  //   setRevealing(true);
  //   setShowDice(false);
  //   setClashSide("player");
  //   playFight();
  //   triggerImpactFx();

  //   const specialDamage = 20;
  //   const specialHeal = 10;
  //   addLogEntry(
  //     `You used SPECIAL and dealt ${specialDamage} damage, healed ${specialHeal} HP.`
  //   );
  //   flashBanner("Special Used");

  //   setTimeout(() => {
  //     setClashSide(null);

  //     // Apply effects
  //     let ko = false;
  //     setBotHP((hp) => {
  //       const newHP = clamp(hp - specialDamage, 0, MAX_HP);
  //       if (newHP <= 0) ko = true;
  //       return newHP;
  //     });
  //     setPlayerHP((hp) => clamp(hp + specialHeal, 0, MAX_HP));

  //     // Sounds
  //     playDamageTaken();
  //     playDamageDone();
  //     playHealDone();

  //     // Reset meter
  //     setPlayerSpecialMeter(0);

  //     // Proceed to next turn
  //     setTimeout(() => {
  //       if (ko) {
  //         endGame("player");
  //       } else {
  //         setShowDice(true);
  //         setTurn("bot");
  //         setRevealing(false);
  //       }
  //     }, RESULT_HOLD_MS);
  //   }, CLASH_MS);
  // }, [
  //   rolling,
  //   revealing,
  //   turn,
  //   playerSpecialMeter,
  //   playFight,
  //   triggerImpactFx,
  //   playDamageTaken,
  //   playDamageDone,
  //   playHealDone,
  //   handleTurnComplete,
  // ]);

  // Player Special move
  const doSpecial = React.useCallback(async () => {
    if (rolling || revealing || turn !== "player") return;
    if (playerSpecialMeter < 5) return;

    setLastActionTime(Date.now());
    setRevealing(true);
    setShowDice(false);

    // Lock avatars to center and mark attacker
    setClashSide("player");
    playFight();
    triggerImpactFx();

    // Start sprites for special: player = powerPunch, bot = punched
    (async () => {
      try {
        await playerSprite.play("power", {
          fps: POWER_PUNCH_FPS,
          loop: true,
        });
      } catch {
        playerSprite
          .play("punch", { fps: PUNCH_FPS, loop: true })
          .catch(() => {});
      }
    })();

    botSprite.play("punched", { fps: PUNCHED_FPS, loop: true }).catch(() => {});

    const specialDamage = 20;
    const specialHeal = 10;
    addLogEntry(
      `You used SPECIAL and dealt ${specialDamage} damage, healed ${specialHeal} HP.`
    );
    flashBanner("Special Used");

    setTimeout(() => {
      // End clash pose
      setClashSide(null);

      // Reset sprites back to idle
      playerSprite.setIdle();
      botSprite.setIdle();

      // Apply effects
      let ko = false;
      setBotHP((hp) => {
        const newHP = clamp(hp - specialDamage, 0, MAX_HP);
        if (newHP <= 0) ko = true;
        return newHP;
      });
      setPlayerHP((hp) => clamp(hp + specialHeal, 0, MAX_HP));

      // Sounds
      playDamageTaken();
      playDamageDone();
      playHealDone();

      // Reset meter
      setPlayerSpecialMeter(0);

      // Proceed to next turn
      setTimeout(() => {
        if (ko) {
          endGame("player");
        } else {
          setShowDice(true);
          setTurn("bot");
          setRevealing(false);
        }
      }, RESULT_HOLD_MS);
    }, CLASH_MS);
  }, [
    rolling,
    revealing,
    turn,
    playerSpecialMeter,
    playFight,
    triggerImpactFx,
    playDamageTaken,
    playDamageDone,
    playHealDone,
    endGame,
    flashBanner,
    addLogEntry,
  ]);

  // Bot Special move (auto when ready)
  // Bot Special move (auto when ready)
  const doBotSpecial = React.useCallback(async () => {
    if (rolling || revealing || turn !== "bot") return;
    if (botSpecialMeter < 5) return;

    setLastActionTime(Date.now());
    setRevealing(true);
    setShowDice(false);

    // Lock avatars to center and mark attacker
    setClashSide("bot");
    playFight();
    triggerImpactFx();

    // Start sprites for special: bot = powerPunch, player = punched
    (async () => {
      try {
        await botSprite.play("power", { fps: POWER_PUNCH_FPS, loop: true });
      } catch {
        botSprite.play("punch", { fps: PUNCH_FPS, loop: true }).catch(() => {});
      }
    })();

    playerSprite
      .play("punched", { fps: PUNCHED_FPS, loop: true })
      .catch(() => {});

    const specialDamage = 20;
    const specialHeal = 10;
    addLogEntry(
      `Opponent used SPECIAL and dealt ${specialDamage} damage, healed ${specialHeal} HP.`
    );
    flashBanner("Special Used");

    setTimeout(() => {
      // End clash pose
      setClashSide(null);

      // Reset sprites back to idle
      botSprite.setIdle();
      playerSprite.setIdle();

      // Apply effects
      let ko = false;
      setPlayerHP((hp) => {
        const newHP = clamp(hp - specialDamage, 0, MAX_HP);
        if (newHP <= 0) ko = true;
        return newHP;
      });
      setBotHP((hp) => clamp(hp + specialHeal, 0, MAX_HP));

      // Sounds
      playDamageTaken();
      playDamageDone();
      playHealDone();

      // Reset meter
      setBotSpecialMeter(0);

      setTimeout(() => {
        if (ko) {
          endGame("bot");
        } else {
          setShowDice(true);
          setTurn("player");
          setRevealing(false);
        }
      }, RESULT_HOLD_MS);
    }, CLASH_MS);
  }, [
    rolling,
    revealing,
    turn,
    botSpecialMeter,
    playFight,
    triggerImpactFx,
    playDamageTaken,
    playDamageDone,
    playHealDone,
    endGame,
    flashBanner,
    addLogEntry,
  ]);

  // Bot decision logic (bot can only heal if player healed last)
  const botDecide = React.useCallback((): "attack" | "heal" => {
    // Gate bot healing: only allowed immediately following a player heal
    if (lastPlayerAction !== "heal") return "attack";

    // If allowed, still respect basic constraints
    if (botHeals <= 0 || botHP >= MAX_HP) return "attack";

    // Simple HP-based preference once gating condition is met
    if (botHP <= 25) return "heal";
    if (botHP <= 50) return Math.random() < 0.4 ? "heal" : "attack";
    return "attack";
  }, [lastPlayerAction, botHeals, botHP]);

  // Drive bot turn
  React.useEffect(() => {
    if (turn !== "bot" || rolling || revealing) return;
    const t = setTimeout(() => {
      if (botSpecialMeter >= 5) {
        doBotSpecial();
      } else {
        const choice = botDecide();
        if (choice === "heal") {
          if (botHeals > 0 && botHP < MAX_HP) doHeal("bot");
          else doAttack("bot");
        } else {
          doAttack("bot");
        }
      }
    }, BOT_ACT_DELAY_MS);
    return () => clearTimeout(t);
  }, [
    turn,
    rolling,
    revealing,
    botDecide,
    doAttack,
    doHeal,
    botHeals,
    botHP,
    showRetroMessage,
    playAudienceCheer,
    playAudienceBoo,
    botSpecialMeter,
    doBotSpecial,
  ]);

  const reset = React.useCallback(() => {
    setPlayerHP(MAX_HP);
    setBotHP(MAX_HP);
    setPlayerHeals(MAX_HEALS);
    setBotHeals(MAX_HEALS);
    setTurn("player");
    setRolling(false);
    setLastRoll(null);
    setLastRoll2(null);
    setLastAction(null);

    setPlayerClutchHeal(false);
    setBotClutchHeal(false);
    setShowDice(true);
    setRevealing(false);
    setShake(false);
    setPlayerHitFx(false);
    setBotHitFx(false);
    setPlayerHealFx(false);
    setBotHealFx(false);
    setPlayerLowWarned(false);
    setBotLowWarned(false);
    setPlayerSpecialMeter(0);
    setBotSpecialMeter(0);
    playerTurnDoneRef.current = false;
    botTurnDoneRef.current = false;
  }, []);

  const handleNextChallenge = React.useCallback(() => {
    setPostVersusVisible(false);
    reset();
    // Re-show pre-battle versus countdown
    setShowVersus(true);
  }, [reset]);

  const handleGoHome = React.useCallback(() => {
    navigate(PATHS.LIBRARY);
  }, [navigate]);

  // One-time user interaction unlock for AudioContext (Safari/iOS policies)
  React.useEffect(() => {
    const unlock = async () => {
      // Audio context is now handled automatically by the useGameSounds hook
      window.removeEventListener("pointerdown", unlock);
      window.removeEventListener("keydown", unlock);
      window.removeEventListener("touchstart", unlock);
    };
    window.addEventListener("pointerdown", unlock, { once: true });
    window.addEventListener("keydown", unlock, { once: true });
    window.addEventListener("touchstart", unlock, { once: true });
    return () => {
      window.removeEventListener("pointerdown", unlock);
      window.removeEventListener("keydown", unlock);
      window.removeEventListener("touchstart", unlock);
    };
  }, []);

  // Pre-battle versus countdown
  React.useEffect(() => {
    if (!showVersus) return;
    setTurn("over"); // block controls during intro
    let remaining = 5;
    setVersusCountdown(remaining);
    const timer = setInterval(() => {
      remaining -= 1;
      setVersusCountdown(remaining);
      if (remaining <= 0) {
        clearInterval(timer);
        setShowVersus(false);
        // Show FIGHT banner briefly
        setFightBanner(true);
        setTimeout(() => setFightBanner(false), 900);
        setTurn("player");
      }
    }, 1000);
    return () => clearInterval(timer);
  }, [showVersus]);

  // Begin versus only after opponent is selected
  const handleSelectOpponent = React.useCallback(() => {
    if (!selectedOpponent) return;
    if (selectedOpponent === 2) {
      navigate(PATHS.DICE_SHOOTOUT_B2);
      return;
    }
    setShowOpponentSelect(false);
    setShowVersus(true);
    // Start music when entering versus
    try {
      playBackgroundMusic();
    } catch {}
  }, [selectedOpponent, navigate, playBackgroundMusic]);

  // SFX helper for select clicks
  const onOpponentCardClick = React.useCallback(
    (id: 1 | 2 | 3) => {
      setSelectedOpponent(id);
      playSidebarOpen();
    },
    [playSidebarOpen]
  );

  const playerTurn = turn === "player";
  const over = turn === "over";
  const canPlayerHeal = playerHeals > 0 && playerHP < MAX_HP;
  const playerDisabled = !playerTurn || rolling || revealing || over;

  // Keyboard event handlers
  React.useEffect(() => {
    const handleKeyPress = (event: KeyboardEvent) => {
      if (turn !== "player" || playerDisabled) return; // Only allow when it's player's turn

      switch (event.key.toLowerCase()) {
        case "e":
          event.preventDefault();
          doAttack("player");
          break;
        case "c":
          event.preventDefault();
          if (canPlayerHeal) {
            doHeal("player");
          }
          break;
      }
    };

    window.addEventListener("keydown", handleKeyPress);
    return () => window.removeEventListener("keydown", handleKeyPress);
  }, [turn, playerDisabled, canPlayerHeal, doAttack, doHeal]);

  const openSidebar = React.useCallback(() => {
    setSidebarOpen(true);
    playSidebarOpen();
  }, [playSidebarOpen]);

  const openSettings = React.useCallback(() => {
    setSidebarOpen(false);
    setSettingsOpen(true);
  }, []);

  const openControls = React.useCallback(() => {
    setSidebarOpen(false);
    setControlsOpen(true);
  }, []);

  const [nextNumberId, setNextNumberId] = useState(0);

  const addRetroNumber = React.useCallback(
    (value: number, type: "damage" | "heal", target: "player" | "bot") => {
      const id = nextNumberId;
      setNextNumberId((prev) => prev + 1);

      // Position based on target
      let x, y;
      if (target === "player") {
        x = 20; // Closer to player avatar
        y = 10; // Above the avatar
      } else {
        x = 160; // Closer to bot avatar
        y = 10; // Above the avatar
      }

      setRetroNumbers((prev) => [
        ...prev,
        {
          id,
          value: type === "damage" ? `-${value}` : `+${value}`,
          type,
          x,
          y,
          target,
        },
      ]);

      // Remove the number after animation completes
      setTimeout(() => {
        setRetroNumbers((prev) => prev.filter((num) => num.id !== id));
      }, 800);
    },
    [nextNumberId]
  );

  const triggerAvatarHitTilt = React.useCallback((target: "player" | "bot") => {
    if (target === "player") {
      setPlayerHitTilt(true);
      setTimeout(() => setPlayerHitTilt(false), 400);
    } else {
      setBotHitTilt(true);
      setTimeout(() => setBotHitTilt(false), 400);
    }
  }, []);

  // Initialize shared target at Battle 2 start if none
  React.useEffect(() => {
    if (!isBattleTwo) return;
    if (currentTargetFace == null) {
      const tf = 2 + Math.floor(Math.random() * 5); // 2..6
      setCurrentTargetFace(tf);
    }
  }, [isBattleTwo, currentTargetFace]);

  useEffect(() => {
    playerSprite.setIdle();
    botSprite.setIdle();
  }, [playerSprite.setIdle, botSprite.setIdle]);

  return (
    <div className="dice-shootout-container">
      <GameContainer
        title="DICE RISK"
        bg={IMAGES.DEFAULT_ARCADE_BG}
        arcadeWidth="100%"
        headerRight={
          <div style={{ display: "flex", gap: 28 }}>
            <div
              style={{
                color: "#9b9b9b",
                fontFamily: "Jersey 10",
                fontSize: 28,
              }}
            >
              Tickets {3}
            </div>
            <div
              style={{
                color: "#9b9b9b",
                fontFamily: "Jersey 10",
                fontSize: 28,
              }}
            >
              Points {playerPts}
            </div>
          </div>
        }
      >
        <div
          className={`dice-shootout-wrapper
    ${shake ? "shake" : ""}
    ${jolt ? "jolt" : ""}
    ${sidebarOpen ? "blurred" : ""}
    ${clashSide ? "clash-locked" : ""}
    ${clashSide === "player" ? "attacking-player" : ""}
    ${clashSide === "bot" ? "attacking-bot" : ""}
  `}
        >
          {fightBanner && <div className="banner-fight">FIGHT!</div>}
          {koBanner && <div className="banner-ko">KO!</div>}

          {!isBattleTwo && showOpponentSelect && (
            <div className="opponent-select-overlay">
              <div className="opponent-select-title">Choose Your Opponent</div>
              <div className="opponent-cards">
                <div
                  className={`opponent-card ${
                    selectedOpponent === 1 ? "active" : ""
                  }`}
                  onClick={() => onOpponentCardClick(1)}
                >
                  <img
                    className="frame"
                    src={IMAGES.DICE_SHOOTOUT.CHARACTER_FRAME_1}
                    alt="frame"
                  />
                  <img
                    className="sprite"
                    src={IMAGES.PLAYER_B_AVATAR}
                    alt="opponent 1"
                  />
                </div>
                <div
                  className={`opponent-card ${
                    selectedOpponent === 2 ? "active" : ""
                  }`}
                  onClick={() => onOpponentCardClick(2)}
                >
                  <img
                    className="frame"
                    src={IMAGES.DICE_SHOOTOUT.CHARACTER_FRAME_2}
                    alt="frame"
                  />
                  <img
                    className="sprite"
                    src={IMAGES.DICE_SHOOTOUT.SECOND_FIGHTER}
                    alt="opponent 2"
                  />
                </div>
                <div
                  className={`opponent-card disabled ${
                    selectedOpponent === 3 ? "active" : ""
                  }`}
                >
                  <img
                    className="frame"
                    src={IMAGES.DICE_SHOOTOUT.CHARACTER_FRAME_3}
                    alt="frame"
                  />
                  <div className="coming-soon">Coming Soon</div>
                </div>
              </div>
              <button
                className={`select-btn ${!selectedOpponent ? "disabled" : ""}`}
                disabled={!selectedOpponent}
                onClick={() => {
                  playSidebarOpen();
                  handleSelectOpponent();
                }}
              >
                <img src={IMAGES.DICE_SHOOTOUT.SELECT_BTN} alt="select" />
              </button>
            </div>
          )}

          {postVersusVisible && (
            <div className="versus-overlay">
              <div className="versus-rules">
                <div className="rules-title">Rules</div>
                {isBattleTwo ? (
                  <ul className="rules-list">
                    <li>
                      Roll dice, but avoid rolling a 1. It deals damage to you.
                    </li>
                    <li>Damage is higher if you roll two 1’s.</li>
                    <li>If you roll the target dice face, you gain +1 heal.</li>
                    <li>Take down the enemy before they take you down!</li>
                  </ul>
                ) : (
                  <ul className="rules-list">
                    <li>Take down your opponent before they take you out.</li>
                    <li>Maximum of 3 lives left.</li>
                    <li>Fill up the special meter to gain special ability.</li>
                  </ul>
                )}
              </div>
              <div className="versus-content">
                <div className="versus-title">
                  {isBattleTwo ? "Battle 2" : "Battle 1"}
                </div>
                <img
                  className="versus-lightning"
                  src={IMAGES.DICE_SHOOTOUT.LIGHTNING}
                  alt="lightning"
                />
                <div className="versus-row">
                  <div
                    className={`fighter-intro left ${
                      winnerSide === "player" ? "winner" : ""
                    }`}
                  >
                    {winnerSide === "player" && (
                      <div className="winner-badge">Winner</div>
                    )}
                    <img
                      className="fighter-sprite"
                      src={IMAGES.PLAYER_A_AVATAR}
                      alt="Player"
                    />
                    <img
                      className="nameplate"
                      src={IMAGES.DICE_SHOOTOUT.NAMEPLATE}
                      alt="nameplate"
                    />
                    <div className="fighter-name">Ngannou</div>
                  </div>
                  <img
                    className="versus-icon"
                    src={IMAGES.DICE_SHOOTOUT.VERSUS}
                    alt="vs"
                  />
                  <div
                    className={`fighter-intro right ${
                      winnerSide === "bot" ? "winner" : ""
                    }`}
                  >
                    {winnerSide === "bot" && (
                      <div className="winner-badge">Winner</div>
                    )}
                    <img
                      className="fighter-sprite"
                      src={
                        isBattleTwo || selectedOpponent === 2
                          ? IMAGES.DICE_SHOOTOUT.SECOND_FIGHTER
                          : IMAGES.PLAYER_B_AVATAR
                      }
                      alt="Opponent"
                    />
                    <img
                      className="nameplate"
                      src={IMAGES.DICE_SHOOTOUT.NAMEPLATE}
                      alt="nameplate"
                    />
                    <div className="fighter-name">Jon Jones</div>
                  </div>
                </div>
                <div className="versus-actions">
                  <button
                    className="vs-btn primary"
                    onClick={handleNextChallenge}
                  >
                    Next Challenge
                  </button>
                  <button className="vs-btn" onClick={handleGoHome}>
                    Home
                  </button>
                </div>
              </div>
            </div>
          )}

          {showVersus && (
            <div className="versus-overlay">
              <div className="versus-rules">
                <div className="rules-title">Rules</div>
                {isBattleTwo ? (
                  <ul className="rules-list">
                    <li>
                      Roll dice, but avoid rolling a 1. It deals damage to you.
                    </li>
                    <li>Damage is higher if you roll two 1’s.</li>
                    <li>If you roll the target dice face, you gain +1 heal.</li>
                    <li>Take down the enemy before they take you down!</li>
                  </ul>
                ) : (
                  <ul className="rules-list">
                    <li>Take down your opponent before they take you out.</li>
                    <li>Maximum of 3 lives left.</li>
                    <li>Fill up the special meter to gain special ability.</li>
                  </ul>
                )}
              </div>
              <div className="versus-content">
                <div className="versus-title">
                  {isBattleTwo ? "Battle 2" : "Battle 1"}
                </div>
                <img
                  className="versus-lightning"
                  src={IMAGES.DICE_SHOOTOUT.LIGHTNING}
                  alt="lightning"
                />
                <div className="versus-row">
                  <div className="fighter-intro left">
                    <img
                      className="fighter-sprite"
                      src={IMAGES.PLAYER_A_AVATAR}
                      alt="Player"
                    />
                    <img
                      className="nameplate"
                      src={IMAGES.DICE_SHOOTOUT.NAMEPLATE}
                      alt="nameplate"
                    />
                    <div className="fighter-name">Ngannou</div>
                  </div>
                  <img
                    className="versus-icon"
                    src={IMAGES.DICE_SHOOTOUT.VERSUS}
                    alt="vs"
                  />
                  <div className="fighter-intro right">
                    <img
                      className="fighter-sprite"
                      src={
                        isBattleTwo || selectedOpponent === 2
                          ? IMAGES.DICE_SHOOTOUT.SECOND_FIGHTER
                          : IMAGES.PLAYER_B_AVATAR
                      }
                      alt="Opponent"
                    />
                    <img
                      className="nameplate"
                      src={IMAGES.DICE_SHOOTOUT.NAMEPLATE}
                      alt="nameplate"
                    />
                    <div className="fighter-name">Jon Jones</div>
                  </div>
                </div>
                <div className="versus-count">
                  Starts in {versusCountdown}...
                </div>
              </div>
            </div>
          )}

          {bannerText && (
            <div className={`banner-generic ${bannerClass}`}>{bannerText}</div>
          )}

          {retroMessage && (
            <div className={`retro-message ${retroMessage.type}`}>
              {retroMessage.text}
            </div>
          )}

          {/* Roll Scoreboard */}
          {rollScore != null && (
            <div className="roll-scoreboard">
              <img
                className="scoreboard-bg"
                src={IMAGES.DICE_SHOOTOUT.SCOREBOARD}
                alt="scoreboard"
              />
              <div className="roll-scoreboard-text">{rollScore}</div>
            </div>
          )}

          {/* Impact sparks */}
          {impactSparks.map((s) => (
            <div
              key={s.id}
              className="impact-spark"
              style={{ left: s.left, top: s.top }}
            />
          ))}

          {/* Game Log */}
          <div className="game-log">
            {gameLog.map((entry) => (
              <div key={entry.id} className="log-entry">
                {entry.message}
              </div>
            ))}
          </div>

          {/* Menu Button - Top Left */}
          <button onClick={openSidebar} className="menu-btn" aria-label="menu">
            <GiHamburgerMenu size={20} />
          </button>

          {/* Help Button - Top Right */}
          <button
            onClick={() => setHelpOpen(true)}
            className="help-btn"
            aria-label="battle help"
          >
            <FaQuestionCircle size={20} />
          </button>

          <div className="arena-row">
            {/* Player fighter (left) */}
            <div className="fighter player">
              <div className="hp-over">
                <div className="dice-shootout-playerA-hp">
                  <span>HP: {playerHP}</span>
                  <div className="dice-shootout-playerA-hp-bar">
                    <div
                      className={`dice-shootout-playerA-hp-bar-progress ${
                        playerHP <= 10 && playerHP > 0
                          ? "danger"
                          : playerHP <= 20 && playerHP > 10
                          ? "warning"
                          : ""
                      }`}
                      style={{
                        width: playerHPWidth,
                        height: "100%",
                        transition: "width 260ms ease",
                      }}
                    />
                  </div>
                  {/* Special meter under HP */}
                  <div className="special-meter">
                    {Array.from({ length: 5 }).map((_, idx) => (
                      <div
                        key={idx}
                        className={`special-segment ${
                          idx < playerSpecialMeter ? "filled" : ""
                        }`}
                      />
                    ))}
                  </div>
                </div>
              </div>

              {/* Player avatar (will center during clash via CSS) */}
              <div className="avatar">
                {retroNumbers
                  .filter((n) => n.target === "player")
                  .map((n) => (
                    <div
                      key={n.id}
                      className={
                        n.type === "damage"
                          ? "retro-damage-number"
                          : "retro-heal-number"
                      }
                      style={{ left: n.x, top: n.y }}
                    >
                      {n.value}
                    </div>
                  ))}
                <img
                  className={`${playerHitFx ? "hit" : ""} ${
                    playerHealFx ? "heal" : ""
                  } ${playerTargetGlow ? "target-glow" : ""} ${
                    turn === "player" ? "active-turn" : ""
                  } ${playerHitTilt ? "avatar-hit-tilt" : ""}`}
                  src={playerSprite.currentFrame}
                  alt="Player sprite"
                />
              </div>
            </div>

            {/* Dice center */}
            <div className="dice-center" style={{ opacity: showDice ? 1 : 0 }}>
              <div className={`dice-pair ${rolling ? "rolling" : ""}`}>
                <RiveDice
                  key={`die1-${rolling ? "rolling" : "idle"}-${
                    lastRoll ?? "na"
                  }`}
                  rolling={rolling}
                  onEnd={() => {}}
                  showNumber={null}
                  outcome={lastRoll}
                  size={240}
                />
                <RiveDice
                  key={`die2-${rolling ? "rolling" : "idle"}-${
                    lastRoll2 ?? "na"
                  }`}
                  rolling={rolling}
                  onEnd={() => {}}
                  showNumber={null}
                  outcome={lastRoll2}
                  size={240}
                />
              </div>
              {!rolling && showDice && (
                <div className="turn-cue">
                  {turn === "player"
                    ? "Your turn"
                    : turn === "bot"
                    ? "Opponent's turn"
                    : ""}
                </div>
              )}
            </div>

            {/* Bot fighter (right) */}
            <div className="fighter bot">
              {/* Opponent Dialogue */}
              {opponentDialogue && (
                <div className="opponent-dialogue">
                  <div className="dialogue-background">
                    <img
                      src={IMAGES.DIALOGUE_BOX}
                      alt="dialogue box"
                      style={{ width: "auto", height: "auto" }}
                    />
                    <div className="dialogue-text">{opponentDialogue.text}</div>
                  </div>
                </div>
              )}

              <div className="hp-over">
                <div className="dice-shootout-playerB-hp">
                  <span>HP: {botHP}</span>
                  <div className="dice-shootout-playerB-hp-bar">
                    <div
                      className={`dice-shootout-playerB-hp-bar-progress ${
                        botHP <= 10 && botHP > 0
                          ? "danger"
                          : botHP <= 20 && botHP > 10
                          ? "warning"
                          : ""
                      }`}
                      style={{
                        width: botHPWidth,
                        height: "100%",
                        transition: "width 260ms ease",
                      }}
                    />
                  </div>
                  {/* Bot Special meter under HP */}
                  <div className="special-meter">
                    {Array.from({ length: 5 }).map((_, idx) => (
                      <div
                        key={idx}
                        className={`special-segment ${
                          idx < botSpecialMeter ? "filled" : ""
                        }`}
                      />
                    ))}
                  </div>
                </div>
              </div>

              {/* Bot avatar (will center during clash via CSS) */}
              <div className="avatar">
                {/* Retro numbers for bot */}
                {retroNumbers
                  .filter((n) => n.target === "bot")
                  .map((n) => (
                    <div
                      key={n.id}
                      className={
                        n.type === "damage"
                          ? "retro-damage-number"
                          : "retro-heal-number"
                      }
                      style={{ left: n.x, top: n.y }}
                    >
                      {n.value}
                    </div>
                  ))}
                <img
                  className={`${botHitFx ? "hit" : ""} ${
                    botHealFx ? "heal" : ""
                  } ${botTargetGlow ? "target-glow" : ""} ${
                    turn === "bot" ? "active-turn" : ""
                  } ${botHitTilt ? "avatar-hit-tilt" : ""}`}
                  src={botSprite.currentFrame}
                  alt="Enemy sprite"
                />
              </div>
            </div>
          </div>

          {/* Target scoreboard and unlucky banner (Battle 2) below dice and above actions */}
          {isBattleTwo && (
            <div className="between-dice-and-actions">
              {currentTargetFace && !rolling && showDice && (
                <div className="target-scoreboard">
                  Target Dice: {currentTargetFace}
                </div>
              )}
              {bannerText && bannerClass.includes("banner-danger") && (
                <div
                  className={`banner-generic ${bannerClass} near-scoreboard`}
                >
                  {bannerText}
                </div>
              )}
            </div>
          )}

          {/* Actions */}
          <div className={`dice-shootout-actions ${isBattleTwo ? "b2" : "b1"}`}>
            {!playerDisabled && (
              <>
                <div className="action-button-container">
                  <ActionButton
                    className="attack"
                    handleClick={() => doAttack("player")}
                  >
                    <img src={IMAGES.ATTACK_BTN_ICON} alt="Attack" />
                  </ActionButton>
                  <div className="action-button-label">Attack</div>
                </div>

                <div className="action-button-container">
                  <ActionButton
                    className="heal"
                    handleClick={() => doHeal("player")}
                    disabled={!canPlayerHeal}
                  >
                    <img src={IMAGES.HEAL_BTN_ICON} alt="Heal" />
                  </ActionButton>
                  <div className="action-button-label">
                    Heal ({playerHeals})
                  </div>
                </div>

                {playerSpecialMeter >= 5 && (
                  <div className="action-button-container">
                    <ActionButton
                      className="special"
                      handleClick={() => doSpecial()}
                    >
                      <img src={IMAGES.SPECIAL_ATK_ICON} alt="Special" />
                    </ActionButton>
                    <div className="action-button-label">Special</div>
                  </div>
                )}
              </>
            )}
          </div>
        </div>

        {/* Removed Victory/Defeat popups in favor of post-battle versus overlay */}

        {/* Sidebar Overlay */}
        {sidebarOpen && (
          <div
            className="sidebar-overlay"
            onClick={() => setSidebarOpen(false)}
          >
            <div className="sidebar" onClick={(e) => e.stopPropagation()}>
              <div
                className="sidebar-icon"
                style={{ color: isMusicMuted ? "#9CA3AF" : "#10B981" }}
                data-label={isMusicMuted ? "Unmute Music" : "Mute Music"}
                onClick={toggleMusicMute}
              >
                {isMusicMuted ? <FaVolumeMute /> : <FaMusic />}
              </div>
              <div
                className="sidebar-icon"
                style={{ color: "#8B5CF6" }}
                data-label="Controls"
                onClick={openControls}
              >
                <FaGamepad />
              </div>
              <div
                className="sidebar-icon"
                style={{ color: "#F59E0B" }}
                data-label="Settings"
                onClick={openSettings}
              >
                <FaCog />
              </div>
              <div
                className="sidebar-icon"
                style={{ color: "#06B6D4" }}
                data-label="Home"
              >
                <FaHome />
              </div>
              <div
                className="sidebar-icon"
                style={{ color: "#06B6D4" }}
                data-label="Guide"
              >
                <FaFileAlt />
              </div>
              <div
                className="sidebar-icon"
                style={{ color: "#EC4899" }}
                data-label="Rules"
              >
                <FaScroll />
              </div>
              <div
                className="sidebar-icon"
                style={{ color: "#9CA3AF" }}
                data-label="Menu"
              >
                <FaBars />
              </div>
            </div>

            {/* Close button outside sidebar */}
            <button
              onClick={() => setSidebarOpen(false)}
              className="sidebar-close-btn"
              aria-label="close menu"
            >
              <IoClose size={20} />
            </button>
          </div>
        )}

        {/* Modals */}
        <SettingsModal
          isOpen={settingsOpen}
          onClose={() => setSettingsOpen(false)}
        />
        <ControlsModal
          isOpen={controlsOpen}
          onClose={() => setControlsOpen(false)}
        />
        <Modal
          isOpen={helpOpen}
          onClose={() => setHelpOpen(false)}
          title={isBattleTwo ? "Battle 2 Rules" : "Battle 1 Rules"}
          variant="help"
        >
          <div className="help-rules">
            {!isBattleTwo ? (
              <ul>
                <li>1. Take down your opponent before they take you out.</li>
                <li>2. Maximum of 3 lives left.</li>
                <li>3. Fill up the special meter to gain special ability.</li>
              </ul>
            ) : (
              <ul>
                <li>
                  1. Roll dice, but avoid rolling a 1. It damages you for -5 HP
                  instead.
                </li>
                <li>2. Double 1’s deal more damage to you for -10 HP.</li>
                <li>3. You start with 0 heals. But you can obtain heals.</li>
                <li>
                  4. Rolling any of the dice face to match the target value will
                  grant you +1 heal.
                </li>
                <li>5. Fill your special meter to gain special ability.</li>
                <li>
                  6. Rolling &gt;=10, rolling a double or after each the end of
                  both turns, will fill your special meter by 1.
                </li>
              </ul>
            )}
          </div>
        </Modal>
      </GameContainer>
    </div>
  );
};

export default DiceShootout;


.dice-shootout-wrapper {
    display: flex;
    flex-direction: column;
    justify-content: space-between;
    height: 80vh;
    position: relative;
    width: 100%;
    height: 100%;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    padding: 20px;
    padding-top: 0px; /* Add top padding to move content down */
}

/* CRT scanline + vignette overlay */
.dice-shootout-wrapper::before {
    content: '';
    position: absolute;
    inset: 0;
    pointer-events: none;
    background: repeating-linear-gradient(
        to bottom,
        rgba(255,255,255,0.03),
        rgba(255,255,255,0.03) 1px,
        rgba(0,0,0,0.03) 2px,
        rgba(0,0,0,0.03) 3px
    );
    mix-blend-mode: overlay;
    z-index: 2;
}
.dice-shootout-wrapper::after {
    content: '';
    position: absolute;
    inset: 0;
    pointer-events: none;
    background: radial-gradient(circle at 50% 50%, rgba(0,0,0,0) 40%, rgba(0,0,0,0.35) 80%);
    z-index: 3;
}

/* Game Log */
.game-log {
  position: absolute;
  top: 20px;
  right: 20px;
  width: 300px;
  z-index: 1000;
  pointer-events: none;
}

.log-entry {
  background: rgba(0, 0, 0, 0.8);
  color: #fff;
  font-family: 'Jersey 10';
  font-size: 16px;
  padding: 8px 12px;
  margin-bottom: 8px;
  border-radius: 4px;
  border-left: 3px solid #000000;
  animation: logEntrySlide 0.3s ease-out;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

@keyframes logEntrySlide {
  0% {
    opacity: 0;
    transform: translateX(100%);
  }
  100% {
    opacity: 1;
    transform: translateX(0);
  }
}

/* Retro Message Display */
.retro-message {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  font-family: 'Jersey 10';
  font-size: 48px;
  font-weight: bold;
  text-align: center;
  z-index: 2000;
  pointer-events: none;
  animation: retroMessagePop 2s ease-out forwards;
  text-shadow: 3px 3px 0px #000, -3px -3px 0px #000, 3px -3px 0px #000, -3px 3px 0px #000;
}

.retro-message.double {
  color: #FFD700;
  animation: retroMessagePop 2s ease-out forwards, retroMessageGlow 0.5s ease-in-out infinite alternate;
}

.retro-message.max {
  color: #FF4500;
  animation: retroMessagePop 2s ease-out forwards, retroMessageShake 0.1s ease-in-out infinite;
}

.retro-message.critical {
  color: #FF0000;
  animation: retroMessagePop 2s ease-out forwards, retroMessagePulse 0.3s ease-in-out infinite;
}

@keyframes retroMessagePop {
  0% {
    opacity: 0;
    transform: translate(-50%, -50%) scale(0.5);
  }
  20% {
    opacity: 1;
    transform: translate(-50%, -50%) scale(1.2);
  }
  80% {
    opacity: 1;
    transform: translate(-50%, -50%) scale(1);
  }
  100% {
    opacity: 0;
    transform: translate(-50%, -50%) scale(0.8);
  }
}

@keyframes retroMessageGlow {
  0% { text-shadow: 3px 3px 0px #000, -3px -3px 0px #000, 3px -3px 0px #000, -3px 3px 0px #000, 0 0 10px #FFD700; }
  100% { text-shadow: 3px 3px 0px #000, -3px -3px 0px #000, 3px -3px 0px #000, -3px 3px 0px #000, 0 0 20px #FFD700, 0 0 30px #FFD700; }
}

@keyframes retroMessageShake {
  0%, 100% { transform: translate(-50%, -50%) rotate(0deg); }
  25% { transform: translate(-50%, -50%) rotate(-1deg); }
  75% { transform: translate(-50%, -50%) rotate(1deg); }
}

@keyframes retroMessagePulse {
  0%, 100% { transform: translate(-50%, -50%) scale(1); }
  50% { transform: translate(-50%, -50%) scale(1.1); }
}

/* Opponent Dialogue */
.opponent-dialogue {
  position: absolute;
  top: -60px;
  left: 40%;
  transform: translateX(-50%);
  z-index: 1000;
  animation: dialoguePop 0.3s ease-out;
  text-align: center;
  display: flex;
  align-items: center;
  justify-content: center;
}

.dialogue-background {
  position: relative;
  display: inline-block;
  min-width: 120px;
  max-width: 400px;
}

.dialogue-background img {
  width: 100%;
  height: auto;
  display: block;
}

.dialogue-text {
  position: absolute;
  top: 40%;
  left: 50%;
  transform: translate(-50%, -50%);
  color: #000;
  font-family: 'Jersey 10';
  font-size: 22px;
  font-weight: bold;
  text-align: center;
  padding: 8px 16px;
  width: calc(100% - 24px);
  word-wrap: break-word;
  white-space: normal;
  line-height: 1.2;
  box-sizing: border-box;
}

@keyframes dialoguePop {
  0% {
    opacity: 0;
    transform: translateX(-50%) scale(0.8);
  }
  100% {
    opacity: 1;
    transform: translateX(-50%) scale(1);
  }
}

/* Arena row: player left, dice center, bot right */
.arena-row {
    display: flex;
    justify-content: space-between;
    align-items: center;
    width: 100%;
    max-width: 1200px;
    margin-top: 40px; /* Move arena content down further */
    position: relative;
}

/* Center ONLY avatars during clash; keep stats where they are */
.dice-shootout-wrapper.clash-locked {
  .arena-row {
    position: relative;   /* containing block for absolute-positioned avatars */
    min-height: 300px;  
    align-items: flex-start;  /* match avatar container height to avoid layout jump */
  }

  /* Hide dice while clashing (JS may also toggle visibility) */
  .dice-center {
    display: none !important;
  }

  /* Ensure fighters themselves stay in normal flow so stats remain side-aligned */
  .fighter {
    position: static !important;
  }

  /* Take just the avatar containers out of flow and pin them at the middle */
  .fighter .avatar {
    position: absolute !important;
    bottom: -90%;
    z-index: 50;
    animation: none !important;  /* cancel any container animations during clash */
  }

  /* Player avatar: sits immediately left of center (10px gap from center) */
  .fighter.player .avatar {
    left: calc(60% - 10px);
    transform: translate(-100%, -50%) !important;
  }

  /* Bot avatar: sits immediately right of center (10px gap from center) */
  .fighter.bot .avatar {
    left: calc(40% + 10px);
    transform: translate(0, -50%) !important;
  }

  /* Prevent image-level motion during clash; let sprite do the punch */
  .fighter .avatar img {
    animation: none !important;
  }
}




.fighter {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 10px;
    position: relative;
}

.fighter .hp-over { margin-bottom: 8px; }

.fighter .avatar {
     width: 300px;
     height: 300px;
     display: flex;
     align-items: center;
     justify-content: center;
     transform: translateY(-12px);
 }
 
 .fighter .avatar img {
     width: 100%;
     height: 100%;
     object-fit: contain;
 }

/* Global hit/heal effects for both avatars */
.fighter .avatar img.hit {
    animation: hit-pulse 600ms ease;
}
.fighter .avatar img.heal {
    animation: heal-glow 700ms ease;
}

@keyframes hit-pulse {
    0% {
        transform: scale(0.96);
        filter: brightness(1) saturate(1);
    }
    30% {
        transform: scale(1.06);
        filter: brightness(1.4) saturate(1.2) contrast(1.05);
    }
    60% {
        transform: scale(1.02);
        filter: brightness(1.2) saturate(1.1);
    }
    100% {
        transform: scale(1);
        filter: brightness(1) saturate(1);
    }
}

/* Active turn swaying */
.fighter .avatar img.active-turn {
    animation: active-sway 700ms ease-in-out infinite;
}


.fighter.bot img { transform: scaleX(-1) !important; }

/* Dice center area */
.dice-center {
    display: flex;
    align-items: center;
    justify-content: center;
    position: relative;
    height: 260px; /* lock height to prevent layout shift */
    min-height: 260px;
}

/* Clash animations */
// .clashing-player .fighter.player .avatar { animation: player-clash-in 500ms ease-out forwards, player-clash-hold 1500ms linear 500ms forwards, player-clash-out 500ms ease-in 2000ms forwards; }
// .clashing-player .fighter.bot .avatar { animation: bot-clash-in 500ms ease-out forwards, bot-clash-hold 1500ms linear 500ms forwards, bot-clash-out 500ms ease-in 2000ms forwards; }

// .clashing-bot .fighter.bot .avatar { animation: bot-clash-in 500ms ease-out forwards, bot-clash-hold 1500ms linear 500ms forwards, bot-clash-out 500ms ease-in 2000ms forwards; }
// .clashing-bot .fighter.player .avatar { animation: player-clash-in 500ms ease-out forwards, player-clash-hold 1500ms linear 500ms forwards, player-clash-out 500ms ease-in 2000ms forwards; }

// @keyframes player-clash-in { 0% { transform: translateX(0); } 100% { transform: translateX(450px) scale(1.05); } }
// @keyframes player-clash-hold { 0% { transform: translateX(450px) scale(1.05); } 100% { transform: translateX(450px) scale(1.05); } }
// @keyframes player-clash-out { 0% { transform: translateX(450px) scale(1.05); } 100% { transform: translateX(0) scale(1); } }

// @keyframes bot-clash-in { 0% { transform: translateX(0); } 100% { transform: translateX(-450px) scale(1.05); } }
// @keyframes bot-clash-hold { 0% { transform: translateX(-450px) scale(1.05); } 100% { transform: translateX(-450px) scale(1.05); } }
// @keyframes bot-clash-out { 0% { transform: translateX(-450px) scale(1.05); } 100% { transform: translateX(0) scale(1); } }

/* Screen shake */
.shake {
    animation: screen-shake 520ms cubic-bezier(0.36, 0.07, 0.19, 0.97) both;
}

@keyframes screen-shake {
    10%, 90% { transform: translate3d(-2px, 0, 0) rotate(-0.2deg); }
    20%, 80% { transform: translate3d(2px, 0, 0) rotate(0.2deg); }
    30%, 50%, 70% { transform: translate3d(-6px, 0, 0) rotate(-0.4deg); }
    40%, 60% { transform: translate3d(6px, 0, 0) rotate(0.4deg); }
}

.jolt {
    animation: jolt-pop 240ms ease-out;
}

@keyframes jolt-pop {
    0% { transform: scale(0.98) translateY(0); filter: brightness(1); }
    40% { transform: scale(1.02) translateY(-4px); filter: brightness(1.1); }
    100% { transform: scale(1) translateY(0); filter: brightness(1); }
}

/* Menu Button - Top Left */
.menu-btn {
    width: 44px;
    height: 44px;
    border-radius: 50%;
    background: #fff;
    border: 1px solid #e0e0e0;
    outline: none;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    margin: 20px 0 0 20px; /* reduced top margin to move button up */
    transition: all 120ms ease;
    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    align-self: flex-start; /* Ensure it stays on the left */
}

.menu-btn:hover {
    background: #f8f8f8;
    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    transform: translateY(-1px);
}

.menu-btn svg {
    width: 20px;
    height: 16px;
    color: #333;
}

/* Sidebar overlay */
.sidebar-overlay {
    position: fixed;
    inset: 0;
    background: rgba(0,0,0,0.4);
    z-index: 100;
    backdrop-filter: blur(4px);
    display: flex;
    align-items: flex-start;
    justify-content: flex-start;
}

.sidebar {
    width: 80px;
    height: 100vh;
    background: #000000;
    border-right: 1px solid #333;
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 20px 0;
    gap: 16px;
}

.sidebar-icon {
    width: 48px;
    height: 48px;
    border-radius: 50%;
    background: #333;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: all 120ms ease;
    color: #fff;
    font-size: 20px;
    position: relative;
}

.sidebar-icon:hover {
    background: #444;
    transform: scale(1.1);
    box-shadow: 0 4px 12px rgba(255,255,255,0.2);
}

.sidebar-icon:hover::after {
    content: attr(data-label);
    position: absolute;
    left: 60px;
    top: 50%;
    transform: translateY(-50%);
    background: rgba(0, 0, 0, 0.8);
    color: #fff;
    padding: 8px 12px;
    border-radius: 6px;
    font-size: 14px;
    font-weight: 500;
    white-space: nowrap;
    z-index: 102;
    animation: textGlow 1.5s ease-in-out infinite alternate;
    box-shadow: 0 0 10px rgba(255, 255, 255, 0.3);
}

@keyframes textGlow {
    from {
        text-shadow: 0 0 5px #fff, 0 0 10px #fff, 0 0 15px #fff;
        box-shadow: 0 0 10px rgba(255, 255, 255, 0.3);
    }
    to {
        text-shadow: 0 0 10px #fff, 0 0 20px #fff, 0 0 30px #fff;
        box-shadow: 0 0 20px rgba(255, 255, 255, 0.5);
    }
}

.sidebar-close-btn {
    position: absolute;
    top: 20px;
    right: 20px;
    width: 44px;
    height: 44px;
    border-radius: 50%;
    background: #fff;
    border: 1px solid #e0e0e0;
    outline: none;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: all 120ms ease;
    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    z-index: 101;
}

.sidebar-close-btn:hover {
    background: #f8f8f8;
    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    transform: translateY(-1px);
}

.sidebar-close-btn svg {
    width: 20px;
    height: 16px;
    color: #333;
}

/* Blur effect for main content when sidebar is open */
.dice-shootout-wrapper.blurred {
    filter: blur(4px);
    pointer-events: none;
    transition: filter 200ms ease;
}

.dice-shootout-playerB {
    display: flex;
    align-items: flex-start; /* Align HP bar top with avatar top */
    justify-content: center;
    // gap: 30px;
    transform: translate(-12px, 10px);
    will-change: transform;

    &-hp {
        display: flex;
        flex-direction: column;
        gap: 10px;

        span {
            font-family: 'Jersey 10';
            font-weight: 400;
            font-style: Regular;
            font-size: 32px;
            line-height: 100%;
            letter-spacing: 0%;
            text-transform: uppercase;
            text-align: right;
            flex: 1;

        }
    }

    &-hp-bar {
        height: 30px;
        width: 240px;
        border: 1px solid #D9D9D9;

        &-progress {
            background: linear-gradient(180deg, #FF0000 2.43%, #C53535 110.94%);
            &.low {
                animation: lowhp-blink 900ms ease infinite;
            }
        }
    }

    &-avatar {
        height: 180px;
        width: 180px;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 0;
        position: relative;

        img {
            width: 100%;
            height: 100%;
            border-radius: 50%;
            object-fit: contain;
        }

        img.hit {
            animation: hit-pulse 600ms ease;
            box-shadow: 0 0 0 0 rgba(255,0,0,0.6);
        }

        img.heal {
            animation: heal-glow 700ms ease;
            box-shadow: 0 0 0 0 rgba(0,255,128,0.6);
        }

        img.active-turn {
            animation: active-sway 700ms ease-in-out infinite;
            box-shadow: none;
            filter: none;
        }

    }
}


.dice-shootout-playerA {
    display: flex;
    flex-direction: column;
    align-items: flex-end;
    gap: 10px;
    transform: translate(50px, 20px);

    &-hp {
        display: flex;
        flex-direction: column;
      align-items: center;
      gap: 5px;

        span {
            font-family: 'Jersey 10';
        font-size: 18px;
        color: #fff;
        text-shadow: 2px 2px 0px #000;
        align-self: flex-start;
        margin-top: 5px;
      }

      &-bar {
        width: 200px;
        height: 20px;
        background: rgba(0, 0, 0, 0.5);
        border: 2px solid #fff;
        border-radius: 6px;
        overflow: hidden;
      }

      &-hp-bar-progress {
        background: linear-gradient(90deg, #00ff00 0%, #00cc00 100%);
        border-radius: 4px;
        transition: width 260ms ease;
      }
    }

    &-avatar {
      width: 180px;
      height: 180px;
      position: relative;
    display: flex;
    align-items: center;
    justify-content: center;
    }
}

.dice-shootout-playerA-hp-bar-progress.warning {
  background: linear-gradient(90deg, #ffff00 0%, #ffcc00 100%) !important;
}

.dice-shootout-playerA-hp-bar-progress.danger {
  background: linear-gradient(90deg, #ff0000 0%, #cc0000 100%) !important;
  animation: hpBlink 0.8s ease-in-out infinite;
}

.dice-shootout-playerA-hp-bar-progress {
  background: linear-gradient(90deg, #00ff00 0%, #00cc00 100%) !important;
}

.dice-shootout-playerB {
    display: flex;
    flex-direction: column;
    align-items: flex-start;
    gap: 10px;
    transform: translate(-50px, -20px);

    &-hp {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 5px;

        span {
            font-family: 'Jersey 10';
            font-size: 18px;
            color: #fff;
            text-shadow: 2px 2px 0px #000;
            align-self: flex-start;
            margin-top: 5px;
        }

        &-bar {
            width: 200px;
            height: 20px;
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid #fff;
            border-radius: 6px;
            overflow: hidden;
        }

        &-hp-bar-progress {
            background: linear-gradient(90deg, #00ff00 0%, #00cc00 100%);
            border-radius: 4px;
            transition: width 260ms ease;
        }
    }

    &-avatar {
        width: 180px;
        height: 180px;
        position: relative;
        display: flex;
        align-items: center;
        justify-content: center;
    }
}

.dice-shootout-playerB-hp-bar-progress.warning {
  background: linear-gradient(90deg, #ffff00 0%, #ffcc00 100%) !important;
}

.dice-shootout-playerB-hp-bar-progress.danger {
  background: linear-gradient(90deg, #ff0000 0%, #cc0000 100%) !important;
  animation: hpBlink 0.8s ease-in-out infinite;
        }

.dice-shootout-playerB-hp-bar-progress {
  background: linear-gradient(90deg, #00ff00 0%, #00cc00 100%) !important;
}

.dice-shootout-actions {
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 20px;
    margin-top: -80px;
    min-height: 80px; /* Reserve space so other elements don't move when buttons disappear */
    position: relative;
    .action-button {
        transition: transform 120ms ease, filter 120ms ease;
    
    }
    .action-button.attack {
        filter: drop-shadow(0 2px 0 rgba(255,0,128,0.6)) drop-shadow(0 0 8px rgba(255,80,160,0.4));
    }
    .action-button.heal {
        filter: drop-shadow(0 2px 0 rgba(0,255,128,0.6)) drop-shadow(0 0 8px rgba(80,255,160,0.4));
    }
    .action-button:active {
        transform: scale(0.95);
    }
}

.dice-shootout-actions.b1 {
    margin-top: 10px;
}
.dice-shootout-actions.b2 {
    margin-top: -80px;
}

/* Fight cloud */
.fight-cloud {
    position: absolute;
    left: 50%;
    top: 55%;
    transform: translate(-50%, -60%);
    pointer-events: none;
    animation: cloud-pop 500ms ease-out forwards;
    z-index: 10;
}
.fight-cloud img {
    width: 300px;
    height: 300px;
    object-fit: contain;
    filter: drop-shadow(0 6px 16px rgba(0,0,0,0.35));
}
@keyframes cloud-pop {
    0% { transform: translate(-50%, -60%) scale(0.6); opacity: 0; }
    40% { transform: translate(-50%, -60%) scale(1.1); opacity: 1; }
    100% { transform: translate(-50%, -60%) scale(1); opacity: 0.95; }
}

/* Tilt during clash */
.clashing-player .fighter.player .avatar img {
    transform-origin: center bottom;
    animation: player-tilt 500ms ease-in-out;
}
.clashing-player .fighter.bot .avatar img {
    transform-origin: center bottom;
    animation: bot-tilt 500ms ease-in-out;
}

.clashing-bot .fighter.player .avatar img {
    transform-origin: center bottom;
    animation: player-tilt 500ms ease-in-out;
}
.clashing-bot .fighter.bot .avatar img {
    transform-origin: center bottom;
    animation: bot-tilt 500ms ease-in-out;
}

@keyframes player-tilt { 0% { transform: rotate(0deg); } 50% { transform: rotate(8deg); } 100% { transform: rotate(0deg); } }
@keyframes bot-tilt { 0% { transform: rotate(0deg); } 50% { transform: rotate(-8deg); } 100% { transform: rotate(0deg); } }

.action-button-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 8px;
}

.action-button-label {
    font-family: 'Jersey 10', monospace;
    font-size: 16px;
    font-weight: bold;
    color: #fff;
    text-shadow: 2px 2px 0 #000;
    text-align: center;
}

/* Retro pixel Street Fighter style damage/heal numbers */
.retro-damage-number {
    position: absolute;
    font-family: 'Courier New', monospace;
    font-weight: bold;
    font-size: 32px;
    color: #8B4513; /* Reddish-brown like in the reference */
    text-shadow: 
        2px 2px 0 #000,
        -2px -2px 0 #000,
        2px -2px 0 #000,
        -2px 2px 0 #000,
        1px 1px 0 #000,
        -1px -1px 0 #000,
        1px -1px 0 #000,
        -1px 1px 0 #000;
    z-index: 1000;
    pointer-events: none;
    animation: retroNumberPop 0.8s ease-out forwards;
    transform-origin: center;
}

.retro-heal-number {
    position: absolute;
    font-family: 'Courier New', monospace;
    font-weight: bold;
    font-size: 32px;
    color: #00FF5D; /* Bright green for healing */
    text-shadow: 
        2px 2px 0 #000,
        -2px -2px 0 #000,
        2px -2px 0 #000,
        -2px 2px 0 #000,
        1px 1px 0 #000,
        -1px -1px 0 #000,
        1px -1px 0 #000,
        -1px 1px 0 #000;
    z-index: 1000;
    pointer-events: none;
    animation: retroNumberPop 0.8s ease-out forwards;
    transform-origin: center;
}

@keyframes retroNumberPop {
    0% {
        opacity: 0;
        transform: scale(0.3) translateY(0);
        filter: brightness(1.5);
    }
    20% {
        opacity: 1;
        transform: scale(1.2) translateY(-10px);
        filter: brightness(2);
    }
    40% {
        transform: scale(1.1) translateY(-15px);
        filter: brightness(1.8);
    }
    60% {
        transform: scale(1.05) translateY(-20px);
        filter: brightness(1.5);
    }
    80% {
        opacity: 1;
        transform: scale(1) translateY(-25px);
        filter: brightness(1.2);
    }
    100% {
        opacity: 0;
        transform: scale(0.8) translateY(-35px);
        filter: brightness(1);
    }
}

/* Avatar hit tilt animation */
@keyframes avatarHitTilt {
    0% {
        transform: rotate(0deg);
    }
    25% {
        transform: rotate(-8deg);
    }
    50% {
        transform: rotate(-5deg);
    }
    75% {
        transform: rotate(-2deg);
    }
    100% {
        transform: rotate(0deg);
    }
}

.avatar-hit-tilt {
    animation: avatarHitTilt 0.4s ease-out forwards;
}

/* Remove old damage/heal box styles */
.player-delta-area {
    display: none;
}

@keyframes retro-hit {
    0% { transform: translateY(-8px) scale(0.6) rotate(-6deg); opacity: 0; }
    40% { transform: translateY(-18px) scale(1.1) rotate(-2deg); opacity: 1; }
    60% { transform: translateY(-14px) scale(1) rotate(0deg); opacity: 1; }
    100% { transform: translateY(-10px) scale(1) rotate(1deg); opacity: 0.95; }
}

@keyframes heal-glow {
    0% { box-shadow: 0 0 0 0 rgba(0,255,128,0.0); }
    30% { box-shadow: 0 0 16px 6px rgba(0,255,128,0.5); }
    100% { box-shadow: 0 0 0 0 rgba(0,255,128,0.0); }
}

@keyframes delta-pop {
    0% { transform: scale(0.8) translateY(8px); opacity: 0; }
    30% { transform: scale(1.05) translateY(-4px); opacity: 1; }
    100% { transform: scale(1) translateY(0); opacity: 1; }
}

@keyframes lowhp-blink {
    0%, 100% { filter: saturate(1) brightness(1); }
    50% { filter: saturate(1.6) brightness(1.3); }
}

/* Persistent dice area */
.dice-persistent {
    display: flex;
    align-items: center;
    justify-content: center;
    animation: dice-float 3s ease-in-out infinite;
    position: relative;
}

.dice-pair {
    display: flex;
    gap: 40px;
    align-items: center;
    justify-content: center;
    position: relative;
    
    &.rolling {
        animation: dice-bounce 700ms ease-out;
    }
}

.dice-pair .rive-dice:first-child {
    transform: translateX(-20px) translateY(-20px);
}

.dice-pair .rive-dice:last-child {
    transform: translateX(20px) translateY(200px);
}

.turn-cue {
    position: absolute;
    top: -28px;
    font-family: 'Jersey 10';
    font-size: 18px;
    letter-spacing: 1px;
    color: #fff;
    padding: 4px 10px;
    border-radius: 10px;
    background: rgba(0,0,0,0.35);
    border: 1px solid rgba(255,255,255,0.25);
    text-transform: uppercase;
    animation: cue-fade 600ms ease;
}

@keyframes cue-fade {
    0% { opacity: 0; transform: translateY(6px); }
    100% { opacity: 1; transform: translateY(0); }
}

/* active glow removed per request */

@keyframes active-sway {
    0%, 100% { transform: translateX(0) scale(1.12); }
    50% { transform: translateX(6px) scale(1.12); }
}

@keyframes dice-float {
    0%, 40% { transform: translateY(0); }
    40% { transform: translateY(-10px); }
}

@keyframes dice-bounce {
    0% { transform: translateY(-4px) scale(0.98); }
    10% { transform: translateY(0) scale(1.04); }
    30% { transform: translateY(-20px) scale(1); }
    10% { transform: translateY(0) scale(1); }
}

/* HP bar hit feedback */
.hp-hit {
    animation: hp-hit-flash 300ms ease;
}

@keyframes hp-hit-flash {
    0% { filter: brightness(1) saturate(1); }
    30% { filter: brightness(1.6) saturate(1.4); }
    70% { filter: brightness(1) saturate(1); }
}

/* Impact spark */
.impact-spark {
    position: absolute;
    width: 56px;
    height: 56px;
    border-radius: 50%;
    pointer-events: none;
    animation: spark-pop 420ms ease-out;
    background: radial-gradient(circle, rgba(94, 71, 71, 0.9) 0%, rgba(255,200,120,0.8) 35%, rgba(255,120,120,0.0) 70%);
}

@keyframes spark-pop {
    0% { transform: scale(0.6); opacity: 0; }
    30% { transform: scale(1.1); opacity: 1; }
    100% { transform: scale(1.4); opacity: 0; }
}

.side-menu-container {
    position: absolute;
    height: calc(100% + 10px);
    width: 387px;
    background: #121212;
    padding: 16px 4px;
    top: -5px;
    left: -5px;
    border: 5px solid #FFFFFF47;

    &-back-btn {
        font-family: 'Jersey 10';
        font-weight: 400;
        font-style: Regular;
        font-size: 32px;
        line-height: 100%;
        letter-spacing: 0%;
        text-transform: uppercase;
        cursor: pointer;

    }


    &-game-attr {
        display: flex;
        align-items: center;
        gap: 10px;

        .game-attribute {
            display: flex;
            align-items: center;
            gap: 6px;

            span {
                width: 40px;
                height: 20px;
                background: #797777;
                border-radius: 4px;
            }
        }
    }

    .divider {
        width: 100%;
        height: 2px;
        background: #524D5A;
    }

    .intro {
        margin: 14px 0px 20px;
        text-align: center;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 20px;

        &-copy {
            font-family: 'Jersey 10';
            font-weight: 400;
            font-style: Regular;
            font-size: 16px;
            line-height: 100%;
            letter-spacing: 0%;
            text-align: center;
            text-transform: uppercase;
            color: #FFFFFF;

        }
    }

    .section {
        padding: 20px;
        
        &-title {
            font-family: 'Jersey 10';
            font-weight: 400;
            font-style: Regular;
            font-size: 20px;
            line-height: 100%;
            letter-spacing: 0%;
            text-align: center;
            text-transform: uppercase;
            color: #fff;
            margin-bottom: 14px;

        }
    }

}

.roll-scoreboard {
    position: absolute;
    inset: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    pointer-events: none;
    z-index: 1500;
    transform: translateY(-200px);
}
.roll-scoreboard .scoreboard-bg { top: 25; width: 250px; height: 150px; image-rendering: pixelated; filter: drop-shadow(0 6px 20px rgba(0,0,0,0.45)); }
.roll-scoreboard .roll-scoreboard-text {
    position: absolute;
    color: #ffffff;
    font-family: 'Jersey 10';
    font-size: 72px;
    text-shadow: 3px 3px 0 #000;
    animation: score-pop 400ms ease-out;
}
@keyframes score-pop {
    0% { transform: scale(0.6); opacity: 0; filter: brightness(1.4); }
    50% { transform: scale(1.15); opacity: 1; filter: brightness(1.2); }
    100% { transform: scale(1); opacity: 1; filter: brightness(1); }
}

.versus-overlay {
    position: fixed;
    inset: 0;
    background: #000;
    z-index: 3000;
    display: flex;
    align-items: center;
    justify-content: center;
}
.versus-content { position: relative; }
.versus-lightning {
    position: absolute;
    top: 18%;
    left: 50%;
    transform: translateX(-50%);
    height: 400px;
    width: auto;
    image-rendering: pixelated;
    opacity: 0.55;
    z-index: 0; /* behind title and VS icon */
    filter: drop-shadow(0 8px 18px rgba(0,255,255,0.25));
}
/* ensure title and row are above */
.versus-title, .versus-row { position: relative; z-index: 1; }
.versus-content {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 24px;
    color: #fff;
    text-align: center;
    padding-top: 120px; /* ensure content sits below the top title */
}
.versus-title {
    font-family: 'Jersey 10';
    font-size: 64px;
    letter-spacing: 2px;
    text-transform: uppercase;
    text-shadow: 3px 3px 0 #000;
    margin-bottom: 8px;
    position: absolute;
    top: 40px;
    left: 50%;
    transform: translateX(-50%);
    width: auto;
}
.versus-row {
    display: grid;
    grid-template-columns: 1fr auto 1fr;
    align-items: end;
    gap: 60px;
}
.versus-icon {
    width: 120px;
    height: auto;
    image-rendering: pixelated;
    filter: drop-shadow(0 6px 12px rgba(0,0,0,0.6));
}
.fighter-intro {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 16px;
}
.fighter-intro .fighter-sprite {
    width: 260px;
    height: auto;
    image-rendering: pixelated;
    filter: drop-shadow(0 6px 16px rgba(0,0,0,0.5));
}
.versus-overlay .fighter-intro.right .fighter-sprite {
    transform: scaleX(1);
}
.fighter-intro.left .fighter-sprite {
    transform: translateX(0);
}
.fighter-intro.right .fighter-sprite {
    transform: translateX(0) scaleX(-1); /* face inward */
}
.fighter-intro .nameplate {
    width: 320px;
    height: auto;
    image-rendering: pixelated;
}
.fighter-name {
    position: relative;
    margin-top: -88px;
    font-family: 'Jersey 10';
    font-size: 36px;
    color: #000;
}
.versus-count {
    margin-top: 8px;
    font-family: 'Jersey 10';
    font-size: 24px;
    color: #ddd;
}

.special-meter {
    display: grid;
    grid-template-columns: repeat(5, 1fr);
    gap: 6px;
    margin-top: 8px;
    width: 200px;
}
.special-meter .special-segment {
    height: 14px;
    background: rgba(60, 60, 60, 0.8);
    border: 2px solid #222;
    box-shadow: inset 0 0 0 2px #000;
    image-rendering: pixelated;
}
.special-meter .special-segment.filled {
    background: linear-gradient(180deg, #FFD700 0%, #CFA800 100%);
    box-shadow: inset 0 0 0 2px #704c00, 0 0 8px rgba(255, 215, 0, 0.5);
}
.dice-shootout-actions .action-button.special {
    filter: drop-shadow(0 2px 0 rgba(255,215,0,0.7)) drop-shadow(0 0 10px rgba(255,215,0,0.5));
    animation: special-shimmer 1200ms ease-in-out infinite;
}
@keyframes special-shimmer {
    0% { filter: drop-shadow(0 2px 0 rgba(255,215,0,0.6)) drop-shadow(0 0 6px rgba(255,215,0,0.3)); }
    50% { filter: drop-shadow(0 2px 0 rgba(255,215,0,0.9)) drop-shadow(0 0 14px rgba(255,215,0,0.6)); }
    100% { filter: drop-shadow(0 2px 0 rgba(255,215,0,0.6)) drop-shadow(0 0 6px rgba(255,215,0,0.3)); }
}

/* Retro button polish */
.dice-shootout-actions .action-button img {
    image-rendering: pixelated;
}
.dice-shootout-actions .action-button:hover {
    filter: brightness(1.1) drop-shadow(0 4px 0 rgba(0,0,0,0.3)) drop-shadow(0 0 10px rgba(255,255,255,0.15));
    transform: translateY(-2px) scale(1.03);
}
.dice-shootout-actions .action-button:active {
    transform: translateY(0) scale(0.98);
}

/* SPECIAL label styling (optional) */
.special-label {
    font-family: 'Jersey 10';
    font-size: 14px;
    letter-spacing: 2px;
    color: #FFD700;
    text-shadow: 2px 2px 0 #000;
    margin-bottom: 4px;
}

/* FIGHT/KO banners */
.banner-fight,
.banner-ko {
    position: absolute;
    top: 16%;
    left: 50%;
    transform: translateX(-50%);
    z-index: 2001;
    font-family: 'Jersey 10';
    font-size: 84px;
    color: #FFD700;
    text-shadow: 4px 4px 0 #000, 0 0 24px rgba(255,215,0,0.7);
    animation: banner-pop 600ms ease-out;
    pointer-events: none;
}
.banner-ko { color: #FF3B3B; text-shadow: 4px 4px 0 #000, 0 0 24px rgba(255,0,0,0.7); }
@keyframes banner-pop {
    0% { transform: translateX(-50%) scale(0.6); opacity: 0; }
    60% { transform: translateX(-50%) scale(1.15); opacity: 1; }
    100% { transform: translateX(-50%) scale(1); opacity: 1; }
}

.banner-generic {
    position: absolute;
    top: 80%;
    left: 50%;
    transform: translateX(-50%);
    z-index: 2001;
    font-family: 'Jersey 10';
    font-size: 64px;
    color: #FFD700;
    text-shadow: 4px 4px 0 #000, 0 0 24px rgba(255,215,0,0.7);
    animation: banner-pop 600ms ease-out;
    pointer-events: none;
}
.banner-generic.banner-danger {
    top: 70px;
    color: #FF3B3B;
    text-shadow: 4px 4px 0 #000, 0 0 24px rgba(255,0,0,0.7);
}

.fighter-intro.winner .fighter-sprite {
    filter: drop-shadow(0 0 18px rgba(255,215,0,0.75)) brightness(1.1);
    transform: translateX(0) scale(1.05);
}
.winner-badge {
    position: absolute;
    top: -36px;
    left: 81%;
    transform: translateX(-50%);
    background: linear-gradient(180deg, #FFD700, #CFA800);
    color: #000;
    border: 2px solid #000;
    border-radius: 8px;
    padding: 6px 12px;
    font-family: 'Jersey 10';
    font-size: 20px;
    text-shadow: 1px 1px 0 #fff;
}
.versus-actions {
    display: flex;
    gap: 16px;
    margin-top: 20px;
}
.vs-btn {
    font-family: 'Jersey 10';
    font-size: 18px;
    padding: 10px 18px;
    color: #fff;
    background: #333;
    border: 2px solid #555;
    border-radius: 10px;
    cursor: pointer;
    image-rendering: pixelated;
    transition: transform 120ms ease, filter 120ms ease;
}
.vs-btn.primary {
    background: #E11D48;
    border-color: #9F1239;
}
.vs-btn:hover {
    transform: translateY(-2px);
    filter: brightness(1.1);
}
.vs-btn:active {
    transform: translateY(0) scale(0.98);
}

.versus-rules {
    position: absolute;
    top: 24px;
    right: 24px;
    width: 320px;
    background: rgba(0,0,0,0.7);
    border: 3px solid #fff;
    box-shadow: inset 0 0 0 2px #000, 0 2px 0 rgba(0,0,0,0.4);
    border-radius: 10px;
    padding: 14px 16px;
    color: #fff;
    z-index: 3001;
}
.versus-rules .rules-title {
    font-family: 'Jersey 10';
    font-size: 24px;
    letter-spacing: 1px;
    margin-bottom: 8px;
    color: #FFD700;
    text-shadow: 2px 2px 0 #000;
}
.versus-rules .rules-list {
    margin: 0;
    padding-left: 18px;
    font-family: 'Jersey 10';
    font-size: 16px;
    line-height: 1.3;
}
.versus-rules .rules-list li { margin-bottom: 6px; }

 .opponent-select-overlay {
     position: fixed;
     inset: 0;
     background: #0b1b28;
     z-index: 4000;
     display: flex;
     flex-direction: column;
     align-items: center;
     justify-content: center;
     gap: 24px;
 }
 .opponent-select-title {
     font-family: 'Jersey 10';
     font-size: 64px;
     color: #fff;
     text-shadow: 3px 3px 0 #000;
     text-transform: uppercase;
     margin-bottom: 8px;
 }
 .opponent-cards {
     display: grid;
     grid-template-columns: repeat(3, 260px);
     gap: 40px;
 }
 .opponent-card {
     position: relative;
     width: 260px;
     height: 360px;
     display: flex;
     align-items: center;
     justify-content: center;
     cursor: pointer;
     transition: transform 120ms ease, filter 120ms ease;
 }
 .opponent-card .frame { width: 100%; height: 100%; object-fit: contain; image-rendering: pixelated; }
 .opponent-card .sprite { position: absolute; width: 180px; height: 220px; image-rendering: pixelated; }
 .opponent-card:hover { transform: translateY(-4px); filter: brightness(1.05); }
 .opponent-card.active { filter: drop-shadow(0 0 12px rgba(0,200,255,0.6)); }
 .opponent-card.disabled { opacity: 0.5; pointer-events: none; }
 .opponent-card .coming-soon {
     position: absolute; color: #fff; font-family: 'Jersey 10'; font-size: 22px; text-shadow: 2px 2px 0 #000;
 }
 .select-btn { background: transparent; border: 0; cursor: pointer; transition: transform 120ms ease, filter 120ms ease; }
 .select-btn img { width: 240px; height: auto; image-rendering: pixelated; }
 .select-btn:hover { transform: translateY(-2px) scale(1.03); }
 .select-btn:active { transform: translateY(0) scale(0.98); }
 .select-btn.disabled { opacity: 0.5; pointer-events: none; }

.opponent-card.active .sprite {
    animation: select-sway 900ms ease-in-out infinite;
    transform-origin: bottom center;
}
@keyframes select-sway {
    0%, 100% { transform: translateX(0) scale(1.02); }
    50% { transform: translateX(8px) scale(1.02); }
}

.target-cue {
    position: absolute;
    top: -58px;
    font-family: 'Jersey 10';
    font-size: 20px;
    letter-spacing: 1px;
    color: #FFD700;
    padding: 4px 10px;
    border-radius: 10px;
    background: rgba(0,0,0,0.45);
    border: 1px solid rgba(255,255,255,0.25);
    text-transform: uppercase;
    animation: cue-fade 600ms ease;
}

.target-scoreboard {
    position: relative;
    bottom: 120px;
    font-family: 'Jersey 10';
    font-size: 40px;
    color: #fff128;
    text-shadow: 2px 2px 0 #000, 0 0 10px rgba(0,229,255,0.5);
    animation: cue-fade 600ms ease;
}

/* Golden glow when target is matched */
.target-glow {
    filter: drop-shadow(0 0 16px rgba(0, 237, 95, 0.8)) brightness(1.1);
}

.between-dice-and-actions {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    gap: 10px;
    margin-top: 6px;
    margin-bottom: 8px;
}

.help-btn {
    position: absolute;
    top: 16px;
    right: 20px;
    width: 44px;
    height: 44px;
    border-radius: 50%;
    background: #fff;
    border: 1px solid #e0e0e0;
    outline: none;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: all 120ms ease;
    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    z-index: 1201; /* higher than game-log (1000) */
}
.help-btn:hover { background: #f8f8f8; box-shadow: 0 4px 12px rgba(0,0,0,0.15); transform: translateY(-1px); }
.help-btn svg { width: 20px; height: 20px; color: #333; }

.help-rules ul { padding-left: 18px; }
.help-rules li { font-family: 'Jersey 10'; font-size: 22px; line-height: 1.4; margin-bottom: 6px; }


import { Alignment, Fit, Layout, useRive } from "@rive-app/react-canvas";

const RiveWrapper = () => {
  const { RiveComponent } = useRive({
    src: "btn.riv",
    stateMachines: "Motion",
    autoplay: true,
    layout: new Layout({
      fit: Fit.Cover,
      alignment: Alignment.Center
    })
  });

  return <RiveComponent />;
};

export default RiveWrapper;